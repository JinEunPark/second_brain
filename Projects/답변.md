Web과 WAS의 차이에 대해서 설명해주세요.  
- 기본적으로 web 서버와 was 의 차이점은 정적 컨텐츠를 다루느냐 동적 컨텐츠를 다루느냐의 차이점이고 web 서버로 주로 사용되는 미들웨어는 niginx, was 로 주로 사용되는 미들웨어는 주로 tomcat
- 웹컨테이너이냐 아니냐의 차이점이고 웹 컨테이는 클라이언트의 요청을 처리해 서블렛을 생성할 수 있냐 아니냐의 차이점

Servlet 이란
- 웹에플리케이션 html 태그 등이 삽입되어 웹 에플리케이션 개발에 최적화된 api 

DB SQL 인젝션에 대해서 설명해주세요.  
- 임의의 SQL 을 주입해서 실행해서 DB 가 비정상적인 동작하게 만드는 것
- **Error based SQL Injection** 논리적 에러를 이용한 SQL Injection은 가장 많이 쓰이고, 대중적인 공격 기법입니다. 예를 들어서 select * from Users where id= '' or 1=1; where where 을 참으로 만들어서 공격하는 방법
- **Union based SQL Injection**

Security 코딩에 대해서 설명해주세요.
- 개발 과정에서 보안 취약점을 막으며 개발하는 것을 알고 있고, 예를 들어서 sql injection 을 피하기 위해서 prepareStatement 의 쿼리 문을 실행할 때 리터럴 타입으로 파라미터들을 한번에 포함해 생성하는 것이아니라. prepareStatement 이후에 setString 메소드를 이용해서 외부의 입력쿼리 내용을 변경할 수 없게 만드는것 등들이 있는 것으로 알고 있습니다. 
- 쉬운 예로는 DB 예약어를  파라미터로 받을 수 없게 만드는거

- 개발과정에서 보안 취약점을 막는것 ex) 예를 들어서 error message 에 dp coloum 을 노출시키지 않는다. 와 같은 규칙들이 있는 것으로 알고 있습니다.
- 혹은 임계영역에 동시에 접근하는 경우 synchronized 키워드를 이용해서 동기적으로 동작할 수 있게 만드는 방법

PG 서비스와 VAN 서비스를 아는지 여쭈었습니다.  
- value add network 가맹점과 카드사 중계
- PG payment gateway 온라인 거래 대표가맹점 역할을 수행해서 client -> pg -> van -> 카드사 순으로 이루어짐(pg 사가 있는 이유는 신용거래 정보 보호법 때문에 보안 수준을 갖춘 방법이 필요하기 때문임)
	- 결제방식
		- key-in 결제
			- pg 사의 sdk or api 이용해서 결제시에 카드번호 입력받는 방식
		- 빌링결제
			- 정기결제의 경우에 빌링 키를 이용해서 결제하는 방식
			- 

결제 기반 서비스에서 중요하게 다루는 개발 환경이 있는지 여쭈었습니다.
- 개발문서와 API가 개발자 친화적인가
- 개발자들이 사용하지 않는 언어로 연동할 수밖에 없는 PG사도 있습니다. 계약하려는 PG사가 언어와 무관하게 연동할 수 있는 HTTP API를 제공하고 있는지 확인해 보시길 추천드립니다.

RSA 암호화 방식  
- 비대칭 함호화 방식으로 암호화하는 키와 이를 복호화하는 키가 다른 알고리즘이다.
	- 장점은 보안이 우수하다는 점이다.
	- 단점은 최소공약수 연산은 컴퓨팅 파워가 많이 필요한 연산이라 비용이 크다(1024비트연산)
	- 따라서 이를 보완하기 위해서 실제로 SSL 에서 초기에 RSA 방식으로 암호키를 주고 받고 이후엔 비용이 적은 AES 와 같은 대칭키 알고리즘을 이용한다.

스프링 프레임워크의 장점
- 개발이 용의하고AOP 에 용의함

프로젝트하면서 어려웠던 점이 있다면 추후 보완하였는가?

- 보완하려고 노력 했고 실제로 음료 이미지 인식 서비스를 java processbuilder 를 이용해서 개선시켰다.

프로젝트를 진행하면서 어려웠던점
- ORM을 사용해서 진행했었는데 N+1 문제가 발생해서 이를 해결하는 것이 초기엔 어려웠다.

DB 는 무엇을 써봤냐
- Mysql PostgreSQL
	- MySql 은 멀티스레드 기반으로 동작하며, 이는 동시에 많은 연결을 처리할 수 있다는 장점을 가지고 있는 반면 PostgreSql 은 멀티프로세스로 동작하며 이는 각연결이 독립된 메모리공간으로 가지고 있어 대용량 쿼리와 데이터 이터 분석과 같은 복잡한 에플리케이션에 최적이다.(지리 정보 시스템 너무 좋음)

DB 트렌젝션 현상들 정리
- dirty read : 아직 commit 되지 않은 데이터들을 읽는 것.
- Non-repeatable read: 하나의 트렌젝션 내부에서 동일한 레코드를 2번 조회했을 때 서로 다른 값이 조회되는 것
- Phantom read: 하나의 트렌젝션 내부에서 같은 조건으로 레코드를 조회 했을 때 첫 번째와 다른 레코드가 조회 되는 것
	
DB isolation level

|                  | dirty read | non-repeatable read | phantom read |
| ---------------- | ---------- | ------------------- | ------------ |
| READ UNCOMMITTED | O          | O                   | O            |
| READ COMMIITED   |            | O                   | O            |
| REPEATABLE READ  |            |                     | O            |
| SERIALIZE        |            |                     |              |

1. read uncommited : 각 으랜잭션에서의 변경 내용이 commit 이냐 roll back 여부에 상관 없이 다른 트랜잭션에서 보여지게 됩니다. (중간에 롤백이 반영되지 않는거임)

2. read commited : commit 이 완료된 데이터만을 다른 트렌젝션에서 조회할 수 있는 수준
	- (오라클에서 가장 많이 사용함) Undo 영역에 백엡된 레코드를 이용해서 다른 트렌젝션의 커밋 전의 값을 저장해서 원래 값이 수정되었더라고 커밋 전의 값을 보여줄 수 있음 
	- non repeatable read : 하나의 트렌젝션 사이에 두개의 조회가 일어나면 커밋 전과 커밋 후의 값이 다르게 조회될 수 있다.
	- 하나의 트랜잭션내에서 **동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장해야 한다는 "REPEATABLE READ" 정합성에 어긋**

4. repeatable read : 트랜젝션이 (시작시간이 기준이다)시작되기 전에 커밋된 내용에 대해서만 조회가 가능합니다. (mysql innoDB 스토리지 엔진에서 기본적으로 사용되는 격리수준)
	- MVCC 방식을 이용해서 여러 버전의 스냅샷을 관리해 구현이 가능하다 ex) 현재 트렌잭션이 6번이면 이 트랜잭션 내부에서는 5번까지의 결과에서만 쿼리가 가능하게 만드는 거임(덕분에 동시성이 아주 강해짐)
5.  sealializable 걍 순서대로 격리해서 수행
	
오라클)은 주로 사용되는 아이솔레이션은 read commited 와 serializable 

postgreSQL 은 first update win 정책에 따라서 먼저락을 가지고 있는 트랜잭션이 이기기 나머지는 롤백됨
Mysql 의 경우에는 locking read 를 이용해서 repeatable 에서의 수준을 구현한다.(for update 문법을 이용)

select for update 하면 read 하면서도 locking 쌉가능

스프링 트렌잭션 전파
- 물리트렌젝션 실제로 스테드풀에 의해서 생성된 트렌젝션
	- 논리트렌젝션 물리트렌젝션을 구성하는 여러개의 쿼리
- @Transaction(REQUIRED) 같은 경우에는 하나의 논리 트렌젝션이 실패하더라도 다른 모든 논리트렌젝션이 한번에 실패됨 즉 논리 트렌젝션의 실패로 이어진다.
- @Transaction(REQUIRED_NEW) 이 옵션을 사용하면 해당 쿼리가 이미존재하는 트랜젝션에 참여하는 것이 아니라 새로운 논리 트랜잭션을 만들어서 수행하게된다 .
	- 영화예매의 경우 REQUIRED 옵션을 사용하면 영화를 구매했는데 로그 저장에 실패하면 영화를 구매하는것까지 실패하게된다.
	- 하지만 REQUIRED_NEW 옵션을 사용한 경우에는 로그 저장에 실패하더라도 다른 트랜젝션에 존재하기 때문에 롤백되지 않고 영화구매가 정상저긍로 수행된다.
	SSL (secure socket layer) : secure scoket layer =로 
대칭치 DES 
비대칭은 RSA

SSL 에서 대칭키(DES)를  공유하기 위해서 RSA 방식을 이용하고 이후에 통신에서는 비용이 저렴한 DES 방식을 이용해서 통신한다.

CA 인증서를 발급하는 기관



## **SSL(Secure Sockets Layer)이란**

암호화 기반의 통신 프로토콜이다. HTTPS는 HTTP에 SSL이 결합된 개념이다.

## **SSL 주요 특징**

- SSL 인증서를 통해 클라이언트와 서버 간의 통신을 보증한다.
- 암호화된 데이터를 주고 받는다. 주로 대칭키(공개키) 방식, 비대칭키(비밀키) 암호화방식이 사용된다.
- SSL 통신과정은 handshake라는 과정을 거친다. (handshake -> 데이터전송 -> 세션종료)

## **SSL 통신과정 (handshake 과정)**

> **브라우저에 URL(https://~~)을 입력하여 접속한 이후의 과정이라고 보면 된다.** 

![](https://blog.kakaocdn.net/dn/KgjQe/btqTfCZTa8g/kbY0ukxDMQGOrXhwwhrHL0/img.jpg)

**1) 클라언트 -> 서버**

- 클라이언트는 랜덤데이터를 만들어 서버에 보낸다.
- 클라이언트에서 사용 가능한 암호화방식들을 서버에 보낸다.

**2) 서버 -> 클라이언트**

- 서버 또한 랜덤데이터를 만들어 클라이언트에 보낸다.
- 클라이언트가 보낸 암호화방식들 중에 사용할 방식을 선정하여 클라이언트에 보낸다. 
- SSL 인증서도 같이 보낸다.

> **SSL 인증서**에는 공개키, 인증서 발급자(CA), 도메인 등등의 정보가 담겨있다.

![](https://blog.kakaocdn.net/dn/nVStm/btqThYV5Hu4/ZEEpyp9pNvpjXPQimaEDck/img.jpg)

**3) 클라이언트 -> (공인/사설) CA**

- 서버에게 받은 인증서를 CA를 통해 확인한다. (믿을만한 서버인가 확인하는 과정)
- 공인된 CA(브라우저에 저장된 CA리스트)에서 발급받은 인증서라면 인증서의 공개키로 복호화할 수 있다. 왜냐하면 제대로된 인증서라면 공인CA의 비밀키로 암호화되었기 때문이다. (비대칭키 암호화 방식)  즉, 서버에게 받은 인증서가 믿을만하다는 것이 보증된 것이다. 그러면 브라우저에도 https가 안전하게 연결됐다는 표시가 뜬다.
- 그러나 공인된 CA가 아닌 사설 CA에서 발급받은 인증서라면? 사설 CA는 브라우저에 저장된 CA 리스트에 없을 것이다. 그러니 믿을만한 인증서라고 판단이 되지 않는다. 브라우저에는 https 경고 표시가 뜨게 된다.

> **공인CA 인증서  
> **- 유료  
> - 많은 사람에게 오픈되는 사이트일 때 사용 (ex. Google, Naver 등)  
> - 브라우저에 안전함 표시가 뜸**  
>   
> 사설CA 인증서  
> **- 무료 (keytool, openssl 등을 사용하여 발급 가능)  
> - 브라우저에 안전하지 않음 표시가 뜸  
> - 공인 인증서에 금지된 정보를 포함할 수 있음  
>   
> **자체서명된 인증서**  
> - CA없이 발급된 인증서  
> - 인증서 자체가 CA역할을 하게 됨  
> - 보안은 약하지만 사용이 쉬움

![](https://blog.kakaocdn.net/dn/ctM6BE/btqTjDqydds/5ijBGr94kOgNgTlYB9K5J1/img.jpg)

**4) 클라이언트**

- 1), 2) 에서 생성된 랜덤데이터들을 조합하여 임시key를 만든다.

**5) 클라이언트**

- 임시key를 인증서의 공개키로 암호화한다.

**6) 클라이언트 -> 서버**

- 암호화한 임시key를 서버에 전송한다.

**7) 서버**

- 임시key는 서버에 저장된 비밀키로 복호화할 수 있다. 왜냐하면 인증서의 공개키로 암호화 되었기 때문이다. (비대칭키 암호화방식)

## **드디어!**

서버와 클라이언트가 임시key를 공유하게 되었다. 이후 서버와 클라이언트에서 일련의 과정을 거친 후에 최종 key를 만든다. (주황색 동그라미 key)

이후부터는 주황색 동그라미 key로 암호화된 데이터를 주고 받는다. (대칭키 암호화 방식)

---