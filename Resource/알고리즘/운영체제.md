---
tags:
  - PrioriityQueue
last updated: 
due date: 
Project: 
aliases:
---
--- 
### tasks

> [! Todo] Title
> https://school.programmers.co.kr/tryouts/71931/challenges

### background Information

```java
public long[] solution(int[][] program) {  
    Arrays.sort(program,(i,j)->{  
        if(i[1] == j[1]){  
            return Integer.compare(i[0],j[0]);  
        }  
        return Integer.compare(i[1],j[1]);  
    });  
  
    PriorityQueue<int[]> pq = new PriorityQueue<>((i,j)->{  
        if(i[0] == j[0]){  
            return Integer.compare(i[1],j[1]);  
        }else{  
            return Integer.compare(i[0],j[0]);  
        }  
    });  
    long[] answer = new long[11];  
    int index = 0;  
    long t = 0;  
    int off = 0;  
    while(off < program.length){  
  
        if(pq.isEmpty()){  
            t = program[index][1] +  program[index][2];  
            index++;  
            off++;  
        }else {  
            int[] cur = pq.poll();  
            answer[cur[0]] += (t - cur[1]);  
            off++;  
            t = t + cur[2];  
        }  
  
        if(off == program.length){  
            answer[0] = t;  
        }  
  
        while(index < program.length && t >= program[index][1] ){  
            pq.add(program[index]);  
            index++;  
        }  
    }  
    System.out.println(Arrays.toString(answer));  
    return answer;  
}

Arrays.sort(program,(i,j)->{  

        return Integer.compare(i[1],j[1]);  
    });  
초기에 프로그램을 정렬할 때 시간 순서대로만 정렬했다. 하지만 일반 배열에서도 배열을 정렬할 때 시간순서대로 정렬해되 호출 시간이 같지만 우선순위가 다른 경우를 포함해야한다. 따라서


Arrays.sort(program,(i,j)->{  
        if(i[1] == j[1]){  
            return Integer.compare(i[0],j[0]);  
        }  
        return Integer.compare(i[1],j[1]);  
    });  

아래와 같이 코드를 변경했다.
```

### Study



### Trouble





### shooting
