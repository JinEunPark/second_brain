https://www.acmicpc.net/problem/1463


```java
package run;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.*;  
  
public class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        int[] dp = new int[n+4];  
        dp[1] = 0;  
        dp[2] = 1;  
        dp[3] = 1;  
  
  
        for (int i = 4; i <= n; i++) {  
            List<Integer> list = new ArrayList<>();  
            list.add(dp[i-1] + 1);  
  
            if(i % 2 == 0){  
                list.add(dp[i/2] + 1);  
            }  
  
            if(i % 3 == 0){  
                list.add(dp[i/3] + 1);  
            }  
  
            dp[i] = list.stream().min(Integer::compare).get();  
        }  
  
        System.out.println(dp[n]);  
    }  
}
```


https://www.acmicpc.net/problem/9095

```
package run;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.*;  
  
public class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
  
        int[] stare = new int[n+1];  
  
        for (int i = 1; i <= n; i++) {  
            stare[i] = Integer.parseInt(br.readLine());  
        }  
  
        int[] dp = new int[n+3];  
        dp[1] = stare[1];  
        if(n > 1)  
        dp[2] = stare[1] + stare[2];  
  
        for (int i = 3; i <= n; i++) {  
            dp[i] = Math.max(dp[i-3] + stare[i-1] + stare[i], dp[i-2] + stare[i]);  
        }  
        System.out.println(dp[n]);  
    }  
}
```

https://www.acmicpc.net/problem/9095

```java
package run;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.*;  
  
public class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
  
        List<Integer> list = new ArrayList<>();  
  
        for (int i = 0; i < n; i++) {  
            int m = Integer.parseInt(br.readLine());  
            list.add(m);  
        }  
  
        int max = list.stream().max(Integer::compare).get();  
        int[] dp = new int[max + 4];  
  
        dp[1] = 1;  
        dp[2] = 2;  
        dp[3] = 4;  
  
        for (int i = 4; i <= max; i++) {  
            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];  
        }  
  
        list.forEach(i -> System.out.println(dp[i]));  
    }  
}
```






```sql
package run;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.*;  
  
public class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
  
        int[] dp = new int[n + 3];  
  
        dp[1] = 1;  
        dp[2] = 2;  
        dp[3] = 3;  
  
        for (int i = 4; i <= n; i++) {  
            dp[i] = (dp[i - 1] + dp[i - 2]) % 10007;  
        }  
  
        System.out.println(dp[n]);  
    }  
}```




```java
package run;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.*;  
  
public class Main {  
  
    public static void main(String[] args) throws IOException {  
  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int n = Integer.parseInt(st.nextToken());  
        int[][] rgb = new int[n][3];  
  
        for (int i = 0; i < n; i++) {  
            st = new StringTokenizer(br.readLine());  
            int r = Integer.parseInt(st.nextToken());  
            int g = Integer.parseInt(st.nextToken());  
            int b = Integer.parseInt(st.nextToken());  
            rgb[i][0] = r;  
            rgb[i][1] = g;  
            rgb[i][2] = b;  
        }  
  
        int[][] dp = new int[n][3];  
        dp[0][0] = rgb[0][0];  
        dp[0][1] = rgb[0][1];  
        dp[0][2] = rgb[0][2];  
  
        for (int i = 1; i < n; i++) {  
            for (int j = 0; j < 3; j++) {  
                int min = Integer.MAX_VALUE;  
                for (int k = 0; k < 3; k++) {  
                    if (j != k) {  
                        if (min > dp[i - 1][k] + rgb[i][j])  
                            min = dp[i - 1][k] + rgb[i][j];  
                    }  
                }  
                dp[i][j] = min;  
            }  
        }  
  
        System.out.println(Math.min(dp[n - 1][0], Math.min(dp[n - 1][1], dp[n - 1][2])));  
  
    }  
}
```


https://school.programmers.co.kr/tryouts/71927/challenges

```java
import java.util.*;

class Solution {
        public static String solution(String input_string) {
        Set<String> sets = new HashSet<>();
        Map<String,Integer> map = new HashMap<>();

        map.put(Character.toString(input_string.charAt(0)), 1);

        for (int i = 1; i < input_string.length(); i++) {
            String c = Character.toString(input_string.charAt(i));
            String b = Character.toString(input_string.charAt(i-1));

            if(map.containsKey(c) && map.get(c) >= 1 && !c.equals(b)){
                sets.add(c);
            }else{
                map.putIfAbsent(c,0);
                map.put(c,map.get(c) + 1);
            }
        }
        List<String> list = new ArrayList<>(sets);
        list.sort(String::compareTo);
        String answer = list.stream().reduce("", (i,j)->{
            return i + j;
        });
        
        if(answer.length() == 0) answer = "N";
        return answer;
    }
}

```


https://school.programmers.co.kr/tryouts/71928/challenges

```java
import java.util.*;
import java.lang.Math;
class Solution {
    int max = Integer.MIN_VALUE;
    public void select(int[][] ability, int y, int sum, Set<Integer> v){
        if(y == ability[0].length){
            max = Math.max(max, sum);
            return;
        }
        
        for(int i = 0; i < ability.length; i++){
            if(!v.contains(i)){
                v.add(i);
                select(ability,y+1,sum + ability[i][y],v);
                v.remove(i);
            }
        }
    }
    public int solution(int[][] ability) {
        select(ability, 0,0,new HashSet<>());
         return max;
    }
}

완전 탐색!!
```




https://school.programmers.co.kr/tryouts/71929/challenges

```java
import java.util.*;

class Solution {
        public String getParent(int g, int idx) {
        if (g == 1) {
            return "Rr";
        }
        String parent = getParent(g - 1, (idx / 4));
        if (parent == "RR") return "RR";
        else if (parent == "rr") {
            return "rr";
        } else {
            int bean = idx % 4;
            if (bean == 0) return "RR";
            if (bean == 1 || bean == 2) return "Rr";
            return "rr";
        }

    }

    public String[] solution(int[][] queries) {

        String[] answer = new String[queries.length];
        for (int i = 0; i < queries.length; i++) {
            answer[i] = getParent(queries[i][0],queries[i][1]-1);
        }
        return answer;
    }
}

```






```java
public long[] solution(int[][] program) {  
    Arrays.sort(program,(i,j)->{  
        if(i[1] == j[1]){  
            return Integer.compare(i[0],j[0]);  
        }  
        return Integer.compare(i[1],j[1]);  
    });  
  
    PriorityQueue<int[]> pq = new PriorityQueue<>((i,j)->{  
        if(i[0] == j[0]){  
            return Integer.compare(i[1],j[1]);  
        }else{  
            return Integer.compare(i[0],j[0]);  
        }  
    });  
    long[] answer = new long[11];  
    int index = 0;  
    long t = 0;  
    int off = 0;  
    while(off < program.length){  
  
        if(pq.isEmpty()){  
            t = program[index][1] +  program[index][2];  
            index++;  
            off++;  
        }else {  
            int[] cur = pq.poll();  
            answer[cur[0]] += (t - cur[1]);  
            off++;  
            t = t + cur[2];  
        }  
  
        if(off == program.length){  
            answer[0] = t;  
        }  
  
        while(index < program.length && t >= program[index][1] ){  
            pq.add(program[index]);  
            index++;  
        }  
    }  
    System.out.println(Arrays.toString(answer));  
    return answer;  
}






Arrays.sort(program,(i,j)->{  

        return Integer.compare(i[1],j[1]);  
    });  
초기에 프로그램을 정렬할 때 시간 순서대로만 정렬했다. 하지만 일반 배열에서도 배열을 정렬할 때 시간순서대로 정렬해되 호출 시간이 같지만 우선순위가 다른 경우를 포함해야한다. 따라서


Arrays.sort(program,(i,j)->{  
        if(i[1] == j[1]){  
            return Integer.compare(i[0],j[0]);  
        }  
        return Integer.compare(i[1],j[1]);  
    });  

아래와 같이 코드를 변경했다.
```

https://school.programmers.co.kr/tryouts/71932/challenges

```java
import java.util.*;
class Solution {
    public int[] solution(String command) {
        
        int[] dx = {0,1,0,-1};
        int[] dy = {1,0,-1,0};
        int dir = 0;
        int[] loc = new int[2];
        for(int i = 0; i < command.length(); i++){
            char c = command.charAt(i);
            if(c == 'R'){
                dir = (dir+1) % 4;
            }
            
            if(c == 'L'){
                dir = (dir+3) % 4;
            }
            
            if(c == 'G'){
                loc[0] = loc[0] + dx[dir];
                loc[1] = loc[1] + dy[dir];
            }
            
            if(c == 'B'){
                loc[0] = loc[0] + dx[(dir + 2) % 4];
                loc[1] = loc[1] + dy[(dir + 2) % 4];
            }
            System.out.println(Arrays.toString(loc));
        }
        return loc;
    }
}
```

내가 이 문제를 틀린 이유는 다음과 같다.

```
1. `dir = (dir+1) % 4;`
    
    - 이 연산에서는 `dir`에 1을 더한 후 4로 나눈 나머지를 `dir`에 할당합니다. 즉, `dir`의 값을 1 증가시킨 다음, 그 결과를 4로 나눈 나머지를 새로운 `dir` 값으로 설정합니다.
2. `dir = (dir++) % 4;`
    
    - `dir++`는 후위 증가 연산자이며, `dir`의 현재 값을 사용한 다음에 `dir`의 값을 1 증가시킵니다. 따라서 `(dir++) % 4` 연산은 먼저 `dir`의 현재 값을 4로 나눈 나머지를 계산하고, 그 다음 `dir`의 값을 1 증가시킵니다. 하지만 여기서 중요한 점은, `dir`의 증가가 나머지 연산이 수행된 후에 일어난다는 것이며, 이 증가된 값은 할당되지 않습니다. 결국 이 연산은 `dir`의 원래 값을 4로 나눈 나머지를 `dir`에 다시 할당하고 나서, `dir`을 1 증가시키는데, 증가된 값은 할당되지 않기 때문에 사실상 무시됩니다.


`dir = (dir++) % 4;` 에서의 동작은 다음과 같이 진행됩니다:

1. 현재 `dir`의 값을 복사합니다.
2. 복사된 값에 `% 4` 연산을 적용합니다.
3. 연산의 결과를 `dir`에 할당합니다.
4. 원래의 `dir` 값에 1을 증가시킵니다.

그러나 4번째 단계의 증가 연산은 이미 3번째 단계에서 새로운 값이 `dir`에 할당된 후에 일어나므로 할당된 값에는 영향을 주지 않습니다. 따라서 `(dir++) % 4` 연산의 결과는 `dir`이 증가하기 전의 값에 대한 연산 결과가 됩니다.

반면에 전위 증가 연산자인 `++dir`의 경우, 증가 연산이 먼저 수행되고 그 후에 다른 연산이 진행됩니다. 그래서 `dir = (++dir) % 4;`와 같이 사용하면 `dir`의 값을 먼저 1 증가시킨 후에 `% 4` 연산이 수행됩니다.

```

https://school.programmers.co.kr/tryouts/71933/challenges

```java
import java.util.*;
class Solution {
    public int solution(int[] ability, int number) {
        int answer = 0;
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for(int a: ability){
            pq.add(a);
        }
        
        while(number >0){
            int x = pq.poll();
            int y = pq.poll();
            pq.add(x+y);
            pq.add(x+y);
            number--;
        }
        
        while(!pq.isEmpty()){
            answer += pq.poll();
        }
        
        return answer;
    }
}
```


https://school.programmers.co.kr/tryouts/71934/challenges

```java
import java.util.*;

class Solution {
    public int solution(int[] menu, int[] order, int k) {
        int answer = 0;

        Queue<Integer> q = new LinkedList<>();
        q.add(menu[order[0]]);
        int index = 1;
        int t = 0;
        int last = menu[order[0]];
        while(index < order.length){
            
            t += k;
         
            while(!q.isEmpty() && t >= q.peek()){
                q.poll();
            }
            if(!q.isEmpty()){
                q.add(last + menu[order[index]]);
                last = last + menu[order[index]];
            }else{
                q.add(t + menu[order[index]]);
                last = t + menu[order[index]];
            }
            index++;
            
            if(q.size() > answer){
                answer = q.size();
            }
        }
        
        return answer;
    }
}
```