
https://school.programmers.co.kr/tryouts/71915/challenges
```java
package run;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.*;  
  
import java.util.*;  
class Solution {  
    public boolean isPrime(long n){  
        if(n == 1 || n == 0) return false;  
        for (int i = 2; i <= Math.sqrt(n); i++) {  
            if(n%i == 0) return false;  
        }  
        return true;  
    }  
    public int solution(int n, int k) {  
        int answer = 0;  
        String s = Long.toString(n,k);  
        StringTokenizer st = new StringTokenizer(s,"0");  
        while(st.hasMoreTokens()){  
            String ss = st.nextToken();  
            if(ss.equals("") || ss.equals(" ")) continue;  
            ss = ss.replaceAll(" ","");  
            long num = Long.parseLong(ss);  
            if(isPrime(num)) answer++;  
        }  
        if(answer == 0) answer = -1;  
        return answer;  
    }  
}
```




  https://school.programmers.co.kr/tryouts/71917/challenges
  
```java
import java.util.*;  
  
class Solution {  
    public class Car{  
  
        public Car(int id, String in) {  
            this.id = id;  
            this.in = in;  
        }  
  
        int id;  
        int sum;  
        String in;  
        String out = "23:59";  
        public int getSum(){  
            StringTokenizer  st = new StringTokenizer(in,":");  
            StringTokenizer  st2 = new StringTokenizer(out,":");  
  
            int intime = Integer.parseInt(st.nextToken()) * 60  
                    +  Integer.parseInt(st.nextToken());  
            int outtime = Integer.parseInt(st2.nextToken()) * 60  
                    + Integer.parseInt(st2.nextToken());  
            this.sum = outtime - intime;  
            return this.sum;  
        }  
    }  
  
  
    public int[] solution(int[] fees, String[] records) {  
        int[] answer = {};  
        Map<Integer, List<Car>> m = new HashMap<>();  
        for(String record: records){  
            StringTokenizer st = new StringTokenizer(record);  
            String time = st.nextToken();  
            int num = Integer.parseInt(st.nextToken());  
            String inout = st.nextToken();  
  
            if(inout.equals("IN")){  
                Car c = new Car(num,time);  
                m.putIfAbsent(num,new ArrayList<>());  
                m.get(num).add(c);  
            }else{  
                List<Car> clist = m.get(num);  
                Car c = clist.get(clist.size()-1);  
                c.out = time;  
            }  
        }  
        List<Integer> cars = new ArrayList<>();  
        for(Integer integer: m.keySet()){  
            cars.add(integer);  
        }  
        cars.sort(Integer::compareTo);  
        answer = new int[cars.size()];  
  
        for (int i = 0; i < answer.length; i++) {  
            List<Car> cs = m.get(cars.get(i));  
            cs.stream().forEach(c -> c.getSum());  
            int sum = cs.stream().mapToInt(c -> c.sum).sum();  
            int fee = 0;  
            if(sum - fees[0] > 0){  
                fee += fees[1];  
                sum = sum - fees[0];  
                int x = (sum/fees[2]);  
                if(sum % fees[2] != 0) x++;  
                fee += (x*fees[3]);  
                answer[i] = fee;  
            }else{  
                answer[i] = fees[1];  
            }  
  
        }  
  
        return answer;  
    }  
}
```


https://school.programmers.co.kr/tryouts/71917/challenges



```java
class Solution {
    int ans  = 0;
    int[] array = new int[11];
    public void dfs(int score, int[] info, int[] me, int n){
        if(score == 11){
            int a = 0;
            int b = 0;
            me[10] = n;
            for(int i = 0; i < info.length; i++){
                if(info[i] == 0 && me[i] == 0) continue;
                if(info[i] < me[i]){
                    a += (10 - i);
                }else{
                    b += (10 - i);
                }

            }

            if(ans <= (a-b) && a > b){
                if(ans < a - b){
                    array = me.clone();
                    ans = (a - b);
                    return;
                }
                
                for(int i = 10; i >= 0; i--){
                    if(array[i] == me[i]) continue;
                    if(array[i] < me[i]) {
                        array = me.clone();
                        break;
                    }else{
                        break;
                    }
                }
            }
            
            return;
        }

        // 점수를 뺏는 경우
        if (info[score] < n) {
            me[score] = info[score] + 1;
            dfs(score + 1, info, me, n - (info[score] + 1));
            me[score] = 0; // 원래 상태로 되돌림
        }
        // 점수를 뺏지 못하는 경우
        dfs(score + 1, info, me, n);
    }
    public int[] solution(int n, int[] info) {
        dfs(0,info, new int[11], n);
        if(ans == 0) return new int[]{-1};
        return array;
    }
}
```


https://school.programmers.co.kr/tryouts/71918/challenges


```java
import java.util.*;

class Solution {
    int a = 0;

    public void dfs(int node, int s, int w, Set<Integer> set, boolean[] v, List<List<Integer>> g, int[] info) {
        if (s <= w) {
            a = Math.max(s,a);
            return;
        } else if((s + w) == info.length){
             if (s >= w && s > a) a = s;
            return;
        }
        
        Set<Integer> nset = new HashSet<>(set);
        for(int i: nset){
            if(v[i]) continue;
            v[i] = true;
            int ns = s;
            int nw = w;
            if(info[i] == 0){
                ns++;
            }else{
                nw++;
            }
            set.remove(i);
            set.addAll(g.get(i));
            dfs(i,ns,nw,set,v,g,info);
            set.add(i);
            set.removeAll(g.get(i));
            v[i] = false;

        }
      
    }

    public int solution(int[] info, int[][] edges) {
        int answer = 0;


        List<List<Integer>> g = new ArrayList<>();
        for (int i = 0; i < info.length; i++) {
            g.add(new ArrayList<>());
        }

        for (int i = 0; i < edges.length; i++) {
            g.get(edges[i][0]).add(edges[i][1]);
        }


        boolean[] v = new boolean[info.length];
        v[0] = true;

        Set<Integer> s = new HashSet<>(g.get(0));

        dfs(0, 1, 0, s, v, g, info);
        answer = a;

        return answer;
    }
}



내가 틀린 부분은 
        if (s <= w) 
이  조건문 이었다.
나는 if (s <= w && a < s) 
이렇게 만들었었다.

위와 같이 조건문을 만들게 되면 기존에 답보다 작은 양의 갯수를 가진 재귀들은 무한으로 반복하기 때문에 오류가 발생했다.





```

https://school.programmers.co.kr/tryouts/71919/challenges

```java
import java.util.*;
class Solution {
    public int getValue(int[][] result, int x, int y){
        if(x == 0 && y == 0) return result[x][y];
        if(x == 0){
            return result[x][y-1] + result[x][y];
        }
        if(y == 0){
            return result[x-1][y] + result[x][y];
        }
        //자기자신 더하는 것 빼먹지 말것
        return result[x][y] + result[x-1][y] + result[x][y-1] - result[x-1][y-1];
    }
    public int[][] skillResult(int[][] skills, int n, int m){
        int[][] result = new int[n][m];
        for(int i = 0; i < skills.length; i++){
            int type = skills[i][0];
            int r1 = skills[i][1];
            int c1 = skills[i][2];
            int r2 = skills[i][3];
            int c2 = skills[i][4];
            int v = skills[i][5];
            
            if(type == 1) v = -v;
            
            result[r1][c1] += v;
            
            if(c2+1 < m){
                result[r1][c2+1] += (-v);
            }
            if(r2+1 < n){
                result[r2+1][c1] += -v;
            }
            if(r2+1 < n && c2+1 < m){
                result[r2+1][c2+1] += v;
            }

        }
       
        
        return result;
    }
    
    public int solution(int[][] board, int[][] skill) {
        int answer = 0;
        int[][] result = skillResult(skill, board.length, board[0].length);
        for(int i = 0; i < result.length; i++){
            for(int j = 0; j < result[0].length; j++){
                result[i][j] = getValue(result,i,j);
                if(board[i][j] + result[i][j] > 0){
                    answer++;
                }
            }
        }
        
        return answer;
    }
}


누적합 배열을 통한 풀이 미리 공부할것
```