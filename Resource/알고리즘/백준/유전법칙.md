---
tags:
  - 재귀
last updated: 
due date: 
Project: 
aliases:
---
--- 
### tasks

> [! Todo] Title
> https://school.programmers.co.kr/tryouts/71929/challenges

### background Information

###### 문제 설명

멘델은 완두콩을 이용하여 7년간 실험한 결과, 다음과 같은 특별한 법칙을 발견하였습니다.

1. 둥근 완두 순종(RR)을 자가 수분, 즉 같은 유전자끼리 교배할 경우, 다음 세대에 둥근 완두 순종 형질만 나타난다.
2. 주름진 완두 순종(rr)을 자가 수분할 경우, 다음 세대에 주름진 완두 순종 형질만 나타난다.
3. 두 순종을 교배한 잡종(Rr)을 자가 수분할 경우, 다음 세대의 형질은 RR:Rr:rr=1:2:1의 비율로 나타난다. (아래 그림 참조)

![image1.PNG](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/22c1e8fc-093c-491b-8604-dad8f553b631/image1.PNG)

멘델의 법칙을 공부한 진송이는, 직접 완두콩의 자가 수분 실험을 진행했습니다. 진송이의 실험에서 완두콩 한 개를 자가 수분한 결과는 다음과 같습니다.

1. 각 완두콩은 자가 수분해서 정확히 4개의 완두콩 후손을 남긴다.
2. 잡종 완두콩(Rr)은 자가 수분해서 첫째는 RR, 둘째와 셋째는 Rr, 넷째는 rr 형질의 후손을 남긴다.
3. 순종 완두콩(RR, rr)은 자가 수분해서 자신과 같은 형질의 후손을 남긴다.

잡종 완두콩(Rr) 1대부터 시작한 가계도로 그려보면 그림 2와 같습니다.

![image2.PNG](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/95a0f907-0e3c-4c4e-acfe-bb489685802b/image2.PNG)

진송이는 이러한 완두콩의 자가 수분 실험 결과를 정리하고 싶어합니다. 하지만, 세대를 거듭할수록, 완두콩의 수가 너무 많아져 모든 가계도를 기록하기 어려워졌습니다. 진송이는 가계도를 전부 기록하는 것 대신, 완두콩의 세대와 해당 세대에서 몇 번째 개체인지를 알면 형질을 바로 계산하는 프로그램을 만들려 합니다.

각 세대에서 맨 왼쪽 개체부터 첫 번째, 두 번째, 세 번째, ...개체로 나타냅니다. 예를 들어 그림 2에서 2세대의 네 번째 개체의 형질은 "rr"이며, 3세대의 9번째 개체의 형질은 "RR"입니다.

형질을 알고 싶은 완두콩의 세대를 나타내는 정수 `n`과, 해당 완두콩이 세대 내에서 몇 번째 개체인지를 나타내는 정수 `p`가 2차원 정수 배열 `queries`의 원소로 주어집니다. `queries`에 담긴 순서대로 `n`세대의 `p` 번째 개체의 형질을 문자열 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

---

##### 제한사항

- 1 ≤ `queries`의 길이(쿼리의 개수) ≤ 5
- `queries`의 원소는 [`n`, `p`] 형태입니다.
    - 1 ≤ `n` ≤ 16
    - 1 ≤ `p` ≤ 4n-1

### Study

이 문제를 풀기 위해서는 유전형질을 이해하는 것이 필요한데 부모를 기준으로 이해하는 것이 필요하다.

```java
    public String getParent(int g, int idx) {
		//1세대 인경우 무조건 'Rr'
        if (g == 1) {
            return "Rr";
        }
        //재귀를 통해서 부모의 유전형질을 반환함 세대를 하나 줄이고 (idx / 4) 부모의 자식 번호를 반환한다.
        String parent = getParent(g - 1, (idx / 4));
        //부모가 'RR' 인 경우에 자식은 무조건 'RR'
        if (parent == "RR") return "RR";
        //부모가 'rr' 인겨우에 자식또한 'rr'
        else if (parent == "rr") {
            return "rr";
        } else {
        //자식이 부모의 몇번째 자식 인가는 idx % 4 이다.
            int bean = idx % 4;
            // 부모가 "Rr" 인경우
            if (bean == 0) return "RR";
            if (bean == 1 || bean == 2) return "Rr";
            return "rr";
        }

    }
```

내가 이 문제를 틀린 이유는 다음과 같다.

```
1. `dir = (dir+1) % 4;`
    
    - 이 연산에서는 `dir`에 1을 더한 후 4로 나눈 나머지를 `dir`에 할당합니다. 즉, `dir`의 값을 1 증가시킨 다음, 그 결과를 4로 나눈 나머지를 새로운 `dir` 값으로 설정합니다.
2. `dir = (dir++) % 4;`
    
    - `dir++`는 후위 증가 연산자이며, `dir`의 현재 값을 사용한 다음에 `dir`의 값을 1 증가시킵니다. 따라서 `(dir++) % 4` 연산은 먼저 `dir`의 현재 값을 4로 나눈 나머지를 계산하고, 그 다음 `dir`의 값을 1 증가시킵니다. 하지만 여기서 중요한 점은, `dir`의 증가가 나머지 연산이 수행된 후에 일어난다는 것이며, 이 증가된 값은 할당되지 않습니다. 결국 이 연산은 `dir`의 원래 값을 4로 나눈 나머지를 `dir`에 다시 할당하고 나서, `dir`을 1 증가시키는데, 증가된 값은 할당되지 않기 때문에 사실상 무시됩니다.


`dir = (dir++) % 4;` 에서의 동작은 다음과 같이 진행됩니다:

1. 현재 `dir`의 값을 복사합니다.
2. 복사된 값에 `% 4` 연산을 적용합니다.
3. 연산의 결과를 `dir`에 할당합니다.
4. 원래의 `dir` 값에 1을 증가시킵니다.

그러나 4번째 단계의 증가 연산은 이미 3번째 단계에서 새로운 값이 `dir`에 할당된 후에 일어나므로 할당된 값에는 영향을 주지 않습니다. 따라서 `(dir++) % 4` 연산의 결과는 `dir`이 증가하기 전의 값에 대한 연산 결과가 됩니다.

반면에 전위 증가 연산자인 `++dir`의 경우, 증가 연산이 먼저 수행되고 그 후에 다른 연산이 진행됩니다. 그래서 `dir = (++dir) % 4;`와 같이 사용하면 `dir`의 값을 먼저 1 증가시킨 후에 `% 4` 연산이 수행됩니다.

```

### Trouble





### shooting
