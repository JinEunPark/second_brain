---
tags: 
last updated: 
due date: 
Project: 
aliases:
---
--- 
### tasks

> [! Todo] Title
> https://www.acmicpc.net/problem/2482

### background Information

# 색상환 성공

|시간 제한|메모리 제한|제출|정답|맞힌 사람|정답 비율|
|---|---|---|---|---|---|
|1 초|128 MB|13742|4976|3620|35.539%|

## 문제

색을 표현하는 기본 요소를 이용하여 표시할 수 있는 모든 색 중에서 대표적인 색을 고리 모양으로 연결하여 나타낸 것을 색상환이라고 한다. 미국의 화가 먼셀(Munsell)이 교육용으로 고안한 20색상환이 널리 알려져 있다. 아래 그림은 먼셀의 20색상환을 보여준다.

![](https://upload.acmicpc.net/069ffaec-e512-4352-bbc4-5ed9a20851ee/-/preview/)

그림 1. 먼셀의 20색상환

색상환에서 인접한 두 색은 비슷하여 언뜻 보면 구별하기 어렵다. 위 그림의 20색상환에서 다홍은 빨강과 인접하고 또 주황과도 인접하다. 풀색은 연두, 녹색과 인접하다. 시각적 대비 효과를 얻기 위하여 인접한 두 색을 동시에 사용하지 않기로 한다.

주어진 색상환에서 시각적 대비 효과를 얻기 위하여 서로 이웃하지 않은 색들을 선택하는 경우의 수를 생각해 보자.  먼셀의 20색상환에서 시각적 대비 효과를 얻을 수 있게 10개의 색을 선택하는 경우의 수는 2이지만, 시각적 대비 효과를 얻을 수 있게 11개 이상의 색을 선택할 수 없으므로 이 경우의 수는 0이다.

주어진 정수 N과 K에 대하여, N개의 색으로 구성되어 있는 색상환 (N색상환)에서 어떤 인접한 두 색도 동시에 선택하지 않으면서 서로 다른 K개의 색을 선택하는 경우의 수를 구하는 프로그램을 작성하시오.

## 입력

입력 파일의 첫째 줄에 색상환에 포함된 색의 개수를 나타내는 양의 정수 N(4 ≤ N ≤ 1,000)이 주어지고, 둘째 줄에 N색상환에서 선택할 색의 개수 K(1 ≤ K ≤ N)가 주어진다. 

## 출력

첫째 줄에 N색상환에서 어떤 인접한 두 색도 동시에 선택하지 않고 K개의 색을 고를 수 있는 경우의 수를 1,000,000,003 (10억 3) 으로 나눈 나머지를 출력한다.

## 예제 입력 1 복사

4
2

## 예제 출력 1 복사

2

## 출처

### Study

```java
package run;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.util.Arrays;  
import java.util.StringTokenizer;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        final int mod = 100_000_003;  
  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        int n = Integer.parseInt(br.readLine());  
        int k = Integer.parseInt(br.readLine());  
  
        long[][] dp = new long[n + 1][k + 1];  
        for (int i = 0; i <= n; i++) {  
            dp[i][0] = 1;  
            dp[i][1] = i;  
        }  
  
        for (int i = 3; i <= n; i++) {  
            for (int j = 2; j <= (i + 1) / 2; j++) {  
                dp[i][j] = (dp[i - 2][j - 1] + dp[i - 1][j]) % mod;  
            }  
        }  
  
        System.out.println((dp[n - 3][k - 1] + dp[n - 1][k]) % mod);  
        return;   
    }  
}
```


### Trouble

위의 문제를 풀기 위해서는 약간의 노력이 필요하다.
흠사 nap sack problem 과 비슷하다. 
1 ~ 10 까지의 색상이 존재하고 10개 중 3개를 뽑는다고 가정하자.

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| o   |     |     |     |     |     |     |     |     |     |

위의 표처럼 현재 1의 색상을 칠했을 때는 현재 1 번을 선택했으니 다음 과정은  나머지 9 개에서 2개를 선택하는 경우의 수로 이어진다. 
10, 3
9, 2
8,1 로 이어진다고 할 수 있다.

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| x   |     |     |     |     |     |     |     |     |     |
하지만 선택하지 않았을 때의 경우의 수는 무엇일까 ㅅ선택하지 않았던 경우의 수는 현재 인덱스를 제외하고 나머지에서 3개를 선택하는 과정으로 이어진다. 따라서  10, 3 에서 9,3 으로 이어진다. 이 때 이 모든 경우를 합친다면 점화식으로 만들 수 있다.


아래의 표에서 가로를 선택하는 k 의 갯수  새로를 선택하는 집합의 원소의 수라 가정한다. 그렇다면 n 개에서 위 문제의 조건을 만족하면서 0 개를 선택하는 경우는 집합의 원소이 갯수와 상관없이 항상 1이다.

그렇다면  n 개에서 1 개를 선택하는 경우는 무조건 n의경우의 수가 발생한다.
그렇다면 이후엔 ?
위에서 설명했던 상황을 점화식으로 표현한다면

```
dp[i][j] = dp[i-1][j] + dp[i-2][j-1]; //현재노드를 선택하지 않은경우와 선택한경우이다.
```

| 0   | 0   | 1   | 2   | 3   |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 1   | 1   |     |     |     |     |     |     |     |     |
| 2   | 1   | 2   |     |     |     |     |     |     |     |     |
| 3   | 1   | 3   |     |     |     |     |     |     |     |     |
| 4   | 1   | 4   |     |     |     |     |     |     |     |     |
| 5   | 1   | 5   |     |     |     |     |     |     |     |     |
| 6   | 1   | 6   |     |     |     |     |     |     |     |     |
| 7   | 1   | 7   |     |     |     |     |     |     |     |     |
| 8   | 1   | 8   |     |     |     |     |     |     |     |     |
| 9   | 1   | 9   |     |     |     |     |     |     |     |     |
| 10  | 1   | 10  |     |     |     |     |     |     |     |     |

여기서 주의해야할 점은 위의 점화식은 직선 상의 조건에서 경우의 수를 정의하는 것이다.
따라서 최종 정답 코드는 i 를 선택하면 i-1 ,i +1 도 선택할 수 없게된다.

그러므로 최종답을 구하는 코드는 

```java
(dp[n - 3][k - 1] + dp[n - 1][k]) 
```

### shooting
