

https://www.acmicpc.net/problem/16920



https://www.acmicpc.net/problem/11967



https://www.acmicpc.net/problem/9328
백준 열쇠

```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.stream.Collectors;  
  
class Main {  
  
    static List<int[]> findKeys(Set<Character> keySet, char[][] map) {  
        List<int[]> enters = new ArrayList<>();  
  
        for (int i = 0; i < map.length; i++) {  
            if (map[i][0] == '.' ||  
                    (Character.isAlphabetic(map[i][0]) &&  
                        (keySet.contains(Character.toLowerCase(map[i][0])) ||  
                        Character.isLowerCase(map[i][0]))  
                    )) { //왼 세로  
                enters.add(new int[]{i, 0});  
            }  
            if (map[i][map[0].length - 1] == '.' ||  
                    (Character.isAlphabetic(map[i][map[0].length - 1]) &&  
                            (keySet.contains(Character.toLowerCase(map[i][map[0].length - 1]))||  
                            Character.isLowerCase(map[i][0]))  
                    )) { //오른 세로로  
                enters.add(new int[]{i, map[0].length - 1});  
            }  
        }  
  
        for (int i = 1; i < map[0].length - 1; i++) {  
            if (map[0][i] == '.' ||  
                    (Character.isAlphabetic(map[0][i]) &&  
                            (keySet.contains(Character.toLowerCase(map[0][i]))||  
                            Character.isLowerCase(map[0][i]))  
                    )) {  
                enters.add(new int[]{0, i});  
            }  
            if (map[map.length - 1][i] == '.' ||  
                    (Character.isAlphabetic(map[map.length - 1][i]) &&  
                            (keySet.contains(Character.toLowerCase(map[map.length - 1][i])) ||  
                            Character.isLowerCase(map[map.length - 1][i])  
                            ))) {  
                enters.add(new int[]{map.length - 1, i});  
            }  
        }  
  
        //겉 부분 키 거르기  
        enters.forEach((i)->{  
            if(Character.isAlphabetic(map[i[0]][i[1]])  
                    && Character.isLowerCase(map[i[0]][i[1]]))  
                keySet.add(map[i[0]][i[1]]);  
        });  
        return enters;  
    }  
  
    static void bfs(char[][] map, boolean[][] v, List<int[]> enters, Set<Character> keySet, Set<String> paperSet) {  
        int paper = 0;  
        int[] dx = {1,-1,0,0};  
        int[] dy = {0,0,1,-1};  
  
        Queue<int[]> q = new LinkedList<>();  
        enters.forEach((i)->{  
            q.add(i);  
            v[i[0]][i[1]] = true;  
        });  
  
        while(!q.isEmpty()){  
            int[] c = q.poll();  
            for (int i = 0; i < 4; i++) {  
                int nx = c[0] + dx[i];  
                int ny = c[1] + dy[i];  
  
                if(nx < 0 || nx >= map.length || ny < 0|| ny >= map[0].length || map[nx][ny] == '*'|| v[nx][ny])  
                    continue;  
                if(Character.isAlphabetic(map[nx][ny]) && Character.isLowerCase(map[nx][ny])){  
                    keySet.add(map[nx][ny]);  
                }  
  
                if(Character.isAlphabetic(map[nx][ny])  
                        && Character.isUpperCase(map[nx][ny])  
                        && !keySet.contains(Character.toLowerCase(map[nx][ny])))  
                    continue;  
                if(!paperSet.contains(nx + " " + ny) && map[nx][ny] == '$'){  
                    paperSet.add(nx + " " + ny);  
                    paper++;  
                }  
                v[nx][ny] = true;  
                q.add(new int[]{nx,ny});  
            }  
        }  
  
        return ;  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        StringBuilder sb = new StringBuilder();  
        int test = Integer.parseInt(st.nextToken());  
  
        for (int i = 0; i < test; i++) {  
            st = new StringTokenizer(br.readLine());  
            int n = Integer.parseInt(st.nextToken());  
            int m = Integer.parseInt(st.nextToken());  
            char[][] map = new char[n][m];  
  
            for (int j = 0; j < n; j++) {  
                map[j] = br.readLine().toCharArray();  
            }  
  
            Set<Character> keySet = new HashSet<>();  
            char[] keyArray = br.readLine().toCharArray();  
            if(keyArray[0] != '0'){  
                for (int j = 0; j < keyArray.length; j++) {  
                    keySet.add(keyArray[j]);  
                }  
            }  
  
  
            List<int[]> enters = findKeys(keySet, map);  
            Set<String> paperSet = new HashSet<>();  
            while(true){  
                int ps = paperSet.size();  
                int ks = keySet.size();  
                enters = findKeys(keySet,map);  
                bfs(map,new boolean[n][m],enters,keySet,paperSet);  
                if(ks == keySet.size())  
                    break;  
            }  
            sb.append(paperSet.size()).append("\n");  
        }  
        System.out.println(sb);  
        return;    }  
}
```

음 일단 처음에 BFS 를 시작할 수 있는 입구를 찾기 위한 로직을 설계했다. 모든 테두리를 훑어서 들어갈 수 있다면 그 부분을 큐에 삽입했다.
- 열쇠가 있는 문이거나
- 그냥 뚤려있거나 
그래서 BFS 도중에 열쇠를 찾는다면 다시 BFS 순회를 처음 부터하는 로직을 만들었는데 틀렸다. 생각을 해보니 불확실한 종료 조건이 문제인거 같다.

**정답코드**

```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.stream.Collectors;  
  
class Main {  
  
  
    static int bfs(char[][] map, boolean[][] v, Map<Character,List<int[]>> doorMap, Set<Character> keySet) {  
        int paper = 0;  
        int[] dx = {1, -1, 0, 0};  
        int[] dy = {0, 0, 1, -1};  
  
        Deque<int[]> q = new LinkedList<>();  
        q.add(new int[]{0,0});  
        v[0][0] = true;  
  
  
        while (!q.isEmpty()) {  
            int[] c = q.poll();  
            for (int i = 0; i < 4; i++) {  
                int nx = c[0] + dx[i];  
                int ny = c[1] + dy[i];  
  
                if(nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length || v[nx][ny] || map[nx][ny] == '*')  
                    continue;  
                char cur = map[nx][ny];  
                if(Character.isAlphabetic(cur) && Character.isUpperCase(cur)){  
                    if(!keySet.contains(Character.toLowerCase(cur))) {  
                        // 키를 가지고 방문하지 않았을 경우의 방문처리  
                        doorMap.get(Character.toLowerCase(cur)).add(new int[]{nx,ny});  
                        continue;                    }  
                }  
  
                if(Character.isAlphabetic(cur) && Character.isLowerCase(cur)){//키를 방문한경우  
                    v[nx][ny] = true;  
                    q.add(new int[]{nx, ny});  
                    if(!keySet.contains(cur)){//키를 가지고 있지 않은데 새로운 키를 찾았다면 그간에 방문했던 모든 문들 넣어주기  
                        keySet.add(cur);  
                        List<int[]> doors = doorMap.get(cur);  
                        for (int[] door : doors) {  
                            v[door[0]][door[1]] = true;  
                            q.offer(new int[]{door[0],door[1]});//방문처리후 삽입  
                        }  
                    }  
                    continue;  
                }  
  
                if(cur == '$') {  
                    paper++;  
                }  
  
                v[nx][ny] = true;  
                q.add(new int[]{nx, ny});  
            }  
        }  
  
        return paper;  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        StringBuilder sb = new StringBuilder();  
        int test = Integer.parseInt(st.nextToken());  
  
        for (int i = 0; i < test; i++) {  
            st = new StringTokenizer(br.readLine());  
            int n = Integer.parseInt(st.nextToken());  
            int m = Integer.parseInt(st.nextToken());  
            char[][] map = new char[n + 2][m + 2];  
  
            for (int j = 0; j < n + 2; j++) {  
                Arrays.fill(map[j],'.');  
            }  
  
            for (int j = 1; j < n + 1; j++) {  
                char[] tmp = br.readLine().toCharArray();  
                for (int k = 1; k < m + 1; k++) {  
                    map[j][k] = tmp[k-1];  
                }  
            }  
  
  
            Set<Character> keySet = new HashSet<>();  
            Map<Character, List<int[]>> doorMap = new HashMap<>();//방문한 곳에 문이 있는 좌표 저장.  
  
            char[] keyArray = br.readLine().toCharArray();  
            if (keyArray[0] != '0') {  
                for (int j = 0; j < keyArray.length; j++) {  
                    keySet.add(keyArray[j]);  
                }  
            }  
            char tmpKey = 'a';  
            for (int j = 0; j < 26; j++) {  
  
                doorMap.put((char)(tmpKey + j),new ArrayList<>());  
            }  
  
  
            int answer = bfs(map,new boolean[n+2][m+2],doorMap,keySet);  
            sb.append(answer).append('\n');  
        }  
        System.out.println(sb);  
        return;   
         }  
}
```

실수 했던 부분
```java
if(Character.isAlphabetic(cur) && Character.isUpperCase(cur)){  
                    if(!keySet.contains(Character.toLowerCase(cur))) {  
                        // 키를 가지고 방문하지 않았을 경우의 방문처리  
                        doorMap.get(Character.toLowerCase(cur)).add(new int[]{nx,ny});  
                        continue;                    }  
                }  

```
- 현재 cur 이 대문자일 때 이에 해당하는 문을 만났다는 것
- 그러니 현재 이 문에대한 키를 가지고 있다면 doormap 에 삽입해서 다른 키에 해당하는 문을 찾을 수 있도록 삽입하는 과정이다
- 이 때 현재 문자가 대문자이기 때문에 소문자로 변경하는 로직을 생략해서 절대 키를 가지고 있는 경우를 탐색할 수없었다. 조심할것

**풀이**
이문제를 풀이하기 위해서 주의해야할 점은 키를 찾은 후의 동작이다.
먼저 키를 만난경우 

1. 키를 이미 가지고 있던 경우 해당 칸을 빈칸취급해 큐에 삽입한다
2. 키를 가지고 있지 않은 경우에 이미 방문한 문들중 키가 존재하지 않아서 들어갈 수 없던 경로를 모두 큐에 추가한다.
```java
  if(Character.isAlphabetic(cur) && Character.isLowerCase(cur)){//키를 방문한경우  
                    v[nx][ny] = true;  
                    q.add(new int[]{nx, ny});  
                    if(!keySet.contains(cur)){//키를 가지고 있지 않은데 새로운 키를 찾았다면 그간에 방문했던 모든 문들 넣어주기  
                        keySet.add(cur);  
                        List<int[]> doors = doorMap.get(cur);  
                        for (int[] door : doors) {  
                            v[door[0]][door[1]] = true;  
                            q.offer(new int[]{door[0],door[1]});//방문처리후 삽입  
                        }  
                    }  
                    continue;  
                } 

```

문을 만난경우의 동작도 2가지 케이스로 나뉜다
1. 이미 키를 가지고 있는 상태에서 문을 만난경우 지나갈 수 있으므로 방문처리 후에 큐에 삽입한다.
2. 키가 없는 상태에서 문을 만난 경우 방문 처리하지 않고 접근할수 있는 문을 모아두는 doorMap 에 해당 좌표를 삽입한다.

```java
if(Character.isAlphabetic(cur) && Character.isUpperCase(cur)){  
                    if(!keySet.contains(Character.toLowerCase(cur))) {  
                        // 키를 가지고 방문하지 않았을 경우의 방문처리  
                        doorMap.get(Character.toLowerCase(cur)).add(new int[]{nx,ny});  
                        continue;                    }  
                }  

```


문제를 구분하자면 큐에 턴이 있는 경우이다.

https://www.acmicpc.net/problem/3197
백준 백조의 호수

```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.stream.Collectors;  
  
class Main {  
     static Queue<int[]> swanQ = new LinkedList<>();  
     static Queue<int[]> nextMeltQ = new LinkedList<>();  
  
     static void melt(char[][] map) {  
  
        Queue<int[]> next = new LinkedList<>();  
        Queue<int[]> q = nextMeltQ;  
  
        int[] dx = {0, 0, 1, -1};  
        int[] dy = {1, -1, 0, 0};  
        int size = q.size();  
         for (int i = 0; i < size; i++) {  
             int[] c = q.poll();  
             for (int j = 0; j < 4; j++) {  
                 int nx  = c[0] + dx[j];  
                 int ny  = c[1] + dy[j];  
  
                 if(nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length ||map[nx][ny] == '.' )  
                     continue;  
                 if(map[nx][ny] == 'X'){  
                     map[nx][ny] = '.';  
                     next.add(new int[]{nx,ny});  
                 }  
             }  
         }  
        nextMeltQ = next;  
        return;    }  
  
     private static boolean isMeet(char[][] map, boolean[][] v,  List<int[]> Ls) {  
  
        Queue<int[]> nextSwanQ = new LinkedList<>();  
        int[] L2 = Ls.get(1);  
        Queue<int[]> q = swanQ;  
  
        boolean[][] added = new boolean[map.length][map[0].length];  
  
        int[] dx = {0, 0, 1, -1};  
        int[] dy = {1, -1, 0, 0};  
  
        while (!q.isEmpty()) {  
            int[] c = q.poll();  
            if (Arrays.equals(c, L2)) {  
                return true;  
            }  
  
            for (int i = 0; i < 4; i++) {  
  
                int nx = c[0] + dx[i];  
                int ny = c[1] + dy[i];  
  
                if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length || v[nx][ny])  
                    continue;  
                v[nx][ny] = true;//방문처리를 해줘여함  
  
                if(map[nx][ny] == 'X'){  
                    added[nx][ny] = true;  
                    nextSwanQ.add(new int[]{nx,ny});  
                    continue;                }  
                q.add(new int[]{nx, ny});  
            }  
        }  
        swanQ = nextSwanQ;//다음에 수행큐로 변경  
        return false;  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        int m = Integer.parseInt(st.nextToken());  
        char[][] map = new char[n][m];  
        int answer = 0;  
  
        boolean[][] swanV = new boolean[n][m];  
  
  
        List<int[]> Ls = new ArrayList<>();  
  
        for (int i = 0; i < n; i++) {  
            char[] tmp = br.readLine().toCharArray();  
            for (int j = 0; j < m; j++) {  
                map[i][j] = tmp[j];  
                if (tmp[j] == 'L') Ls.add(new int[]{i, j});  
                if(tmp[j] == '.'|| tmp[j] == 'L') nextMeltQ.add(new int[]{i,j});  
            }  
        }  
  
        swanQ.add(Ls.get(0));  
        swanV[Ls.get(0)[0]][Ls.get(0)[1]] = true; //첫 번째 백조 방문처리  
  
        while (!isMeet(map, swanV,Ls)) {  
  
            melt(map);  
            answer++;  
        }  
  
        System.out.println(answer);  
        return;    }  
}

```

이 문제를 분류하자면 음 큐에 턴이  있는경우이다 한번에 모든 큐를 수행하는 것이 아니라 몇번에 나눠서 수행해 중복 탐색을 줄여서 시간초과를 줄일 수 있었다.


```java
static Queue<int[]> swanQ = new LinkedList<>();  
     static Queue<int[]> nextMeltQ = new LinkedList<>();  
  
     static void melt(char[][] map) {  
  
        Queue<int[]> next = new LinkedList<>();  
        Queue<int[]> q = nextMeltQ;  
  
        int[] dx = {0, 0, 1, -1};  
        int[] dy = {1, -1, 0, 0};  
        int size = q.size();  
         for (int i = 0; i < size; i++) {  
             int[] c = q.poll();  
             for (int j = 0; j < 4; j++) {  
                 int nx  = c[0] + dx[j];  
                 int ny  = c[1] + dy[j];  
  
                 if(nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length ||map[nx][ny] == '.' )  
                     continue;  
                 if(map[nx][ny] == 'X'){  
                     map[nx][ny] = '.';  
                     next.add(new int[]{nx,ny});  
                 }  
             }  
         }  
        nextMeltQ = next;  
        return;    }  
  
     private static boolean isMeet(char[][] map, boolean[][] v,  List<int[]> Ls) {  
  
        Queue<int[]> nextSwanQ = new LinkedList<>();  
        int[] L2 = Ls.get(1);  
        Queue<int[]> q = swanQ;  
  
        boolean[][] added = new boolean[map.length][map[0].length];  
  
        int[] dx = {0, 0, 1, -1};  
        int[] dy = {1, -1, 0, 0};  
  
        while (!q.isEmpty()) {  
            int[] c = q.poll();  
            if (Arrays.equals(c, L2)) {  
                return true;  
            }  
  
            for (int i = 0; i < 4; i++) {  
  
                int nx = c[0] + dx[i];  
                int ny = c[1] + dy[i];  
  
                if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length || v[nx][ny])  
                    continue;  
                v[nx][ny] = true;//방문처리를 해줘여함  
  
                if(map[nx][ny] == 'X'){  
                    added[nx][ny] = true;  
                    nextSwanQ.add(new int[]{nx,ny});  
                    continue;                }  
                q.add(new int[]{nx, ny});  
            }  
        }  
        swanQ = nextSwanQ;//다음에 수행큐로 변경  
        return false;  
    }  
```

위 두함수의 공통점은 현재 큐를 수행하고 다음 수행할 노드들을 새로운 큐에 넣어 벌갈아 수행될 수 있게 한다는 점이다.

