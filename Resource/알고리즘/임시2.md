
https://www.acmicpc.net/problem/1463
복습

```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.stream.Collectors;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int n = Integer.parseInt(st.nextToken());  
  
        int[] dp = new int[n + 5];  
        dp[1] = 0;  
        dp[2] = 1;  
        dp[3] = 1;  
        dp[4] = 2;  
  
        for (int i = 5; i <= n; i++) {  
            List<Integer> nums = new ArrayList<>();  
            if (i % 2 == 0) nums.add(dp[i / 2] + 1);  
            if (i % 3 == 0) nums.add(dp[i / 3] + 1);  
            nums.add(dp[i - 1] + 1);  
            dp[i] = nums.stream().min(Integer::compare).get();  
        }  
          
        System.out.println(dp[n]);  
        return;  
    }  
}
```


복습
https://www.acmicpc.net/problem/9095
```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.stream.Collectors;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        StringBuilder sb = new StringBuilder();  
  
        int test = Integer.parseInt(st.nextToken());  
        List<Integer> tc = new ArrayList<>();  
  
        for (int i = 0; i < test; i++) {  
            tc.add(Integer.parseInt(br.readLine()));  
        }  
  
        int max = tc.stream().max(Integer::compare).get();  
        int[] dp = new int[max+4];  
        dp[1] = 1;  
        dp[2] = 2;  
        dp[3] = 4;  
  
        for (int i = 4; i <= max; i++) {  
            for (int j = 1; j <= 3; j++) {  
                dp[i] += dp[i-j];  
            }  
        }  
  
        tc.forEach((i)->{  
            sb.append(dp[i]).append("\n");  
        });  
  
        System.out.println(sb);  
        return;    }  
}
```


https://www.acmicpc.net/problem/2579
복습 여전히 존나 오래 걸렸다
```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.stream.Collectors;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        StringBuilder sb = new StringBuilder();  
  
        int n = Integer.parseInt(st.nextToken());  
        int[] stair = new int[n+4];  
  
        for (int i = 1; i <= n; i++) {  
            stair[i] = Integer.parseInt(br.readLine());  
        }  
        int[] dp = new int[n+4];  
  
        dp[0] = 0;  
        dp[1] = stair[1];  
        dp[2] = stair[1] + stair[2];  
        dp[3] = Math.max(stair[2] + stair[3], stair[1] + stair[3]);  
  
        for (int i = 4; i <= n; i++) {  
            dp[i] = Math.max(dp[i-2] + stair[i], dp[i-3] + stair[i-1] + stair[i]);  
        }  
  
        System.out.println(dp[n]);  
        return;    }  
}
```

https://www.acmicpc.net/problem/1149
복습
```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.stream.Collectors;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        StringBuilder sb = new StringBuilder();  
  
        int n = Integer.parseInt(st.nextToken());  
        int[][] rgb = new int[n][3];  
        for (int i = 0; i < n; i++) {  
            String[] s = br.readLine().split(" ");  
            for (int j = 0; j < 3; j++) {  
                rgb[i][j] = Integer.parseInt(s[j]);  
            }  
        }  
  
        int[][] dp = new int[n][3];  
        List<Integer> tmp = new ArrayList<>();  
  
        for (int i = 0; i < n; i++) {  
            for (int j = 0; j < 3; j++) {  
                if (i == 0) {  
                    dp[i][j] = rgb[i][j];  
                } else {  
                    tmp = new ArrayList<>();  
                    for (int k = 0; k < 3; k++) {  
                        if (j != k) tmp.add(dp[i - 1][k]);  
                    }  
                    dp[i][j] = Math.min(rgb[i][j] + tmp.get(0), rgb[i][j] + tmp.get(1));  
                }  
            }  
        }  
  
        System.out.println(Math.min(dp[n - 1][0], Math.min(dp[n - 1][1], dp[n - 1][2])));  
        return;    }  
}
```


https://www.acmicpc.net/problem/11659
구간합 구하기 4

```java
import java.io.*;
import java.util.*;

class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        StringBuilder sb = new StringBuilder();

        int n = Integer.parseInt(st.nextToken());
        int test = Integer.parseInt(st.nextToken());

        int[] array = new int[n+2];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            array[i] = Integer.parseInt(st.nextToken());
        }

        for (int i = 1; i <= n; i++) {
            array[i] = array[i] + array[i-1];
        }

        for (int i = 0; i < test; i++) {
            st = new StringTokenizer(br.readLine());
            int s = Integer.parseInt(st.nextToken())-1;
            int e = Integer.parseInt(st.nextToken());

            sb.append(array[e] - array[s]).append("\n");
        }

        System.out.println(sb);
        return;

    }
}

이 문제의 가장 중요한 점은 누적합 배열을 이용해서 구간의 합을 구하는 과정을 빼기 연산 한번으로 단축시키는 것이다.

```


https://www.acmicpc.net/problem/12852
1로 만들기 2
이문제의 중요한 점은 부모를 기록하는 것임 음 이부분은 전에 풀었던 문제에서 배열을 이용해서 부모를 기록하는 법을 배웠다.

```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
  
        int[] parent = new int[n + 4];  
        Arrays.fill(parent, -1);  
        parent[1] = 0;  
        parent[2] = 1;  
        parent[3] = 1;  
  
        int[] dp = new int[n + 4];  
  
        dp[1] = 0;  
        dp[2] = 1;  
        dp[3] = 1;  
        dp[4] = 2;  
  
        for (int i = 4; i <= n; i++) {  
            int index = Integer.MAX_VALUE;  
            int min = Integer.MAX_VALUE;  
  
            if (i % 3 == 0 && min > (dp[i / 3] + 1)) {  
                min = dp[i / 3] + 1;  
                index = i / 3;  
            }  
            if (i % 2 == 0 && min > (dp[i / 2] + 1)) {  
                min = dp[i / 2] + 1;  
                index = i / 2;  
            }  
            if (min > (dp[i - 1] + 1)) {  
                min = dp[i - 1] + 1;  
                index = i - 1;  
            }  
            dp[i] = min;  
            parent[i] = index;  
        }  
  
        StringBuilder sb = new StringBuilder();  
        sb.append(dp[n]).append("\n");  
  
        int p = n;  
        while(parent[p] != -1){  
            sb.append(p).append(" ");  
            p = parent[p];  
        }  
        System.out.println(sb);  
        return;    }  
}
```


https://www.acmicpc.net/problem/1003

```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int test = Integer.parseInt(st.nextToken());  
        List<Integer> cases = new ArrayList<>();  
  
        for (int i = 0; i < test; i++) {  
            cases.add(Integer.parseInt(br.readLine()));  
        }  
  
        int n = cases.stream().max(Integer::compare).get();  
  
        int[][] fibo = new int[n+3][2];  
  
        fibo[0][0] = 1;  
        fibo[1][1] = 1;  
  
        fibo[2][0] = 1;  
        fibo[2][1] = 1;  
  
  
        for (int i = 3; i <= n; i++) {  
            fibo[i][0] = fibo[i-1][0] + fibo[i-2][0];  
            fibo[i][1] = fibo[i-1][1] + fibo[i-2][1];  
        }  
  
        StringBuilder sb = new StringBuilder();  
        for (int i = 0; i < cases.size(); i++) {  
            int x = cases.get(i);  
            sb.append(fibo[x][0]).append(" ").append(fibo[x][1]).append("\n");  
        }  
        System.out.println(sb);  
        return;    }  
}

```

https://www.acmicpc.net/problem/11727

```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int n = Integer.parseInt(st.nextToken());  
        int[] dp = new int[n+3];  
  
        dp[1] = 1;  
        dp[2] = 3;  
        dp[3] = dp[2] + dp[1] * 2;  
  
  
        for (int i = 4; i <= n; i++) {  
            dp[i] = (dp[i-1] + dp[i-2] * 2) % 10007;  
        }  
  
        System.out.println(dp[n]);  
        return;    }  
}

```

이문제의 핵심은 끝나는 도형의 가지수가 하나가 더 증가했다는 점이다 이것 이외에는 [[01 타일]] 과 동일한 알고리즘을 가진다


https://www.acmicpc.net/problem/2193
```java
import java.io.*;
import java.util.*;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken());
        long [] dp = new long[n+3];
        dp[1] = 1;
        dp[2] = 1;
        dp[3] = 2;


        for (int i = 4; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }

        System.out.println(dp[n]);
        return;
    }
}

dp[i - 1] 에 0 을 붙여서 새로운 이친수를 만들고
에[i-2] 에 01 을 붙여서 새로운 이친수를 만드는 알고리즘이다.

```


https://www.acmicpc.net/problem/1912
연속합 
이문제는 진짜 오래 걸렸다 남들은 쉽다던데...

```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int n = Integer.parseInt(st.nextToken());  
  
        long[] nums = new long[n];  
        long[] dp = new long[n];  
  
        st = new StringTokenizer(br.readLine());  
  
        for (int i = 0; i < n; i++) {  
            nums[i] = Integer.parseInt(st.nextToken());  
        }  
        long max = nums[0];  //최댓값을 현재 문제로 초기화
        dp[0] = nums[0];  // 현재 dp 0 은 당연히 첫번째 값
  
  
        for (int i = 1; i < n; i++) {  
            dp[i] = Math.max(dp[i-1] + nums[i], nums[i]); 
            //현재 값 + 전까지의 최대값 vs 현재값
            max = Math.max(max,dp[i]);  
        }  
  
        System.out.println(max);  
        return;    
        }  
}
```


- [11053번. 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)
- [11054번. 가장 긴 바이토닉 부분 수열](https://www.acmicpc.net/problem/11054)
- [11722번. 가장 긴 감소하는 부분 수열](https://www.acmicpc.net/problem/11722)
- [12015번. 가장 긴 증가하는 부분 수열 2](https://www.acmicpc.net/problem/12015)
- [12738번. 가장 긴 증가하는 부분 수열 3](https://www.acmicpc.net/problem/12738)
- [14002번. 가장 긴 증가하는 부분 수열 4](https://www.acmicpc.net/problem/14002)
- [14003번. 가장 긴 증가하는 부분 수열 5](https://www.acmicpc.net/problem/14003)

https://www.acmicpc.net/problem/11055
가장큰 증가하는 부분 수열

```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int n = Integer.parseInt(st.nextToken());  
  
        int[] nums = new int[n];  
        int[] dp = new int[n];  
  
        st = new StringTokenizer(br.readLine());  
  
        for (int i = 0; i < n; i++) {  
            int tmp = Integer.parseInt(st.nextToken());  
            nums[i] = tmp;  
            dp[i] = tmp;  
        }  
  
        for (int i = 0; i < n; i++) {  
            for (int j = i-1; j >= 0; j--) {  
                if(nums[i] > nums[j]){  
                    dp[i] = Math.max(dp[i], nums[i] + dp[j]);  
                }  
            }  
        }  
        System.out.println(Arrays.stream(dp).max().getAsInt());  
        return;    }  
}
```

기본적으로 O(n^2) 알고리즘이다. 
1. dp 배열을 각 수열의 값으로 초기화한다.
2. 반복문을 돌면서 현재 자기보다 뒤에 있고 자기보다 작은 수를 가진 dp 를 더한 값들증 가장 큰값으로 해당  dp 를 초기화한다.

https://www.acmicpc.net/problem/14501
백준 퇴사

```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
    static int max = 0;  
  
    public static void dfs(int time, int pay, int due, int[] t, int[] v){  
        //1.일을 수행한경우  
        //2.일을 수행할 수 없던 경우  
        if(time == due) {  
            if(max < pay) max = pay;  
            return;        }  
        if(time + t[time] <= due){  
            dfs(time + t[time], pay + v[time], due, t,v);  
        }  
        if(time + 1 <= due){  
            dfs(time + 1, pay, due,t,v);  
        }  
    }  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int n = Integer.parseInt(st.nextToken());  
        int[] t = new int[n];  
        int[] v = new int[n];  
  
        for (int i = 0; i < n; i++) {  
            st = new StringTokenizer(br.readLine());  
            t[i] = Integer.parseInt(st.nextToken());  
            v[i] = Integer.parseInt(st.nextToken());  
        }  
  
        dfs(0,0,n,t,v);  
        System.out.println(max);  
        return;    }  
}
```

사실 해당 문제의 분류된 알고리즘은 다이나믹프로그래밍이다. 하지만 n 의 크기가 15 로 매우 작은 점을 보아서 dfs 로 풀이했다. 가장 중요한점은 현시점에 이 일을 한 경우와 하지 않은 경우의 페이중 가장 큰 값을 구하는 부분 문제로 나누는 것이다.

이렇게 dfs 로 풀이하면 탑 다운 방식을 순쉽게 구할 수 있다. 이를 다시 다이나믹 프로그래밍으로 전환한 코드는 다음과 같다.
```java
	package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int n = Integer.parseInt(st.nextToken());  
        int[] t = new int[n];  
        int[] v = new int[n];  
  
        for (int i = 0; i < n; i++) {  
            st = new StringTokenizer(br.readLine());  
            t[i] = Integer.parseInt(st.nextToken());  
            v[i] = Integer.parseInt(st.nextToken());  
        }  
        int[] dp = new int[n + 1];  
  
        for (int i = 0; i < n; i++) {  
            if(i + t[i] <= n){  
                dp[i + t[i]] = Math.max(dp[i + t[i]], dp[i] + v[i]);  
            }  
            dp[i + 1] = Math.max(dp[i], dp[i + 1]);  
        }  
        System.out.println(dp[n]);  
        return;    }  
}

```

위의 코드에 대해서 잠깐 설명
dp[i] : i 까지 근무했을 때 얻을 수 있는 최대의 돈

```java
      if(i + t[i] <= n){  
                dp[i + t[i]] = Math.max(dp[i + t[i]], dp[i] + v[i]);  
            }  
            dp[i + 1] = Math.max(dp[i], dp[i + 1]);  

```

만일 현재 번돈 더하기 i 번째 일이 끝난 후의 돈이 더 크다면 해당 일이 끝나는 날짜에 반영
두번째는 오늘의 누적값을 다음날 가지 누적하기 위함이다.
솔직하게 말하면 이 코드는 만일 코테에서 만났다면 가망이 없다고 생각한다.

https://www.acmicpc.net/problem/15486
퇴사 2

```Java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
  
        int[] t = new int[n];  
        int[] v = new int[n];  
  
        long[] dp = new long[n + 1];  
  
        for (int i = 0; i < n; i++) {  
            st = new StringTokenizer(br.readLine());  
            t[i] = Integer.parseInt(st.nextToken());  
            v[i] = Integer.parseInt(st.nextToken());  
        }  
  
        for (int i = 0; i < n; i++) {  
            if(i + t[i] <= n)  
            dp[i + t[i]] = Math.max(dp[i] + v[i], dp[i + t[i]]);  
            dp[i + 1] = Math.max(dp[i], dp[i + 1]);  
        }  
  
        System.out.println(dp[n]);  
        return;    }  
}
```

알고리즘은 퇴사 1과 같다 하지만 다시 푸는데도 정말 많은 시간이 걸렸다 다른 점은 정수의 범위를 초과하기 때문에 메모이제이션을 long type 으로 선언했다는 것이다.

https://yabmoons.tistory.com/337 이분이 설명을 참 잘해놨다


https://www.acmicpc.net/problem/2748
fibonacci 오랜만에 쉬어갔다.

```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        long[] dp = new long[n + 5];  
        dp[0] = 0;  
        dp[1] = 1;  
        dp[2] = 1;  
        dp[3] = 2;  
        dp[4] = 3;  
  
        for (int i = 4; i <= n; i++) {  
            dp[i] = dp[i-1]  + dp[i-2];  
        }  
        System.out.println(dp[n]);  
        return;    }  
}

```

https://www.acmicpc.net/problem/2240
https://goodbyeanma.tistory.com/118
자두나무 
이문제는 사실 너무 오랜시간 고만해서 위에 나오는 링크를 참고했다 저분 리얼 지니어스나 ㅎ 화나 이만큼 하면 잘될때가 됐는데 응 아니야 될때까지해

```java
import java.io.*;
import java.util.*;

public class Main {
    
    static int T, W;
    static int[][][] dp;
    static int[] input;
    static int maxCount;
    
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        StringTokenizer stk = new StringTokenizer(br.readLine());
        
        T = Integer.parseInt(stk.nextToken()); // 시간
        W = Integer.parseInt(stk.nextToken()); // 자두를 모을 수 있는 최대 거리
        
        input = new int[T+1]; // 자두가 떨어지는 나무의 위치 배열
        dp = new int[3][T+1][W+2]; // 동적 계획법을 위한 배열
        
        // 각 시간마다 자두가 떨어지는 나무의 위치를 입력받음
        for (int i = 1; i <= T; i++) {
            input[i] = Integer.parseInt(br.readLine());
        }
        
        
        for (int i = 1; i <= T; i++) {
            for (int j = 1; j <= W+1; j++) {
                
                // 자두가 떨어지는 나무의 위치가 1이면
                if (input[i] == 1) {
                    // dp[1][i][j] 갱신
                    dp[1][i][j] = Math.max(dp[1][i-1][j] + 1, dp[2][i-1][j-1] + 1);
                    // dp[2][i][j] 갱신
                    dp[2][i][j] = Math.max(dp[1][i-1][j-1], dp[2][i-1][j]);
                } else { // 자두가 떨어지는 나무의 위치가 2이면
                    // 이전 위치와 현재 위치가 같은 경우를 제외
                    if (i == 1 && j == 1) continue;
                    
                    // dp[1][i][j] 갱신
                    dp[1][i][j] = Math.max(dp[1][i-1][j], dp[2][i-1][j-1]);
                    // dp[2][i][j] 갱신
                    dp[2][i][j] = Math.max(dp[1][i-1][j-1] + 1, dp[2][i-1][j] + 1);
                }
            }
        }
        
        // 마지막 시간에 각 위치에서 모을 수 있는 자두의 최대 개수를 계산
        for (int i = 1; i <= W+1; i++) maxCount = Math.max(dp[1][T][i], dp[2][T][i]);
        
        // 결과 출력
        bw.write(maxCount + "");
        bw.close();
        br.close();
        
    }
}

```

이렇게 보면 점화식이 어렵지만 말로 풀면 조금 더 쉬워진다.
우선 나무당 테이블 하나라고 가정한다. 세로축은 시간 가로축은 움직인 횟수(다른 나무로 슝 한경우)

1. 만일 1먼 나무에서 자두가 하나 떨어진다고 가정하자
2. 그러면 1번 나무의 테이블을 업데이트하기 위해서 고려해야할 것은 2가지 이다. (편의를 위해서 지금 현재 1번 나무에서 자두가 뚝! 떨어지는 경우라면)
	1. 움직이지 않고 제자리에서 받아먹는 경우 ->  ``` dp[첫번째 나무][바로 직전시간][동일한 움직임 횟수]``` -> ``` dp[1][i-1][j] + 1```

	2. 2번 나무에서 움직여서 자두를 받아먹는 경우 -> ```dp[두번째나무][바로직전시간][한번 움직이기 전의값]``` -> 여기서 중요한점은 하나 움직이기 전의 값이다. 2 번에 있던경우 1번으로 이동해서 먹어야하니2번에서 1번으러 이동하는데 이때 2번의 값은 현재 j 에서 하나 전이라는 점이다! -> ```dp[2][i-1][j-1] + 1 ```
	3. 결론적으로 
		```java
		dp[1][i][j] = Math.max(dp[1][i-1][j] + 1, dp[2][i-1][j-1] + 1);
		```

그렇다면 i 의 시점에 j 번 이동하고 1 번에 자두가 떨어지는 순간의 2번 나무는 어떻게 해야하는가
```java
	dp[2][i][j] = Math.max(dp[1][i-1][j-1], dp[2][i-1][j]);
```

위에서 볼 수 있듯이 (직전 시간, 움직인 횟수 하나전의 1번 나무) 그리고 (직전 시점, 동일한 이동횟수의 2번 나무) 중 더 큰것으로 업데이트한다.
복습 코드
 
```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int n = Integer.parseInt(st.nextToken());  
        int move = Integer.parseInt(st.nextToken());  
        int[] arr = new int[n + 1];  
        int[][][] dp = new int[3][move + 2][n+1];//움 시간  
  
        for (int i = 1; i <= n; i++) {  
            arr[i] = Integer.parseInt(br.readLine());  
        }  
  
        for (int i = 1; i <= n; i++) {  
            if(arr[i] == 1){  
                for (int j = 1; j <= move+1; j++) {  
                    dp[1][j][i] = Math.max(dp[1][j][i-1] + 1, dp[2][j-1][i-1] + 1);  
                    dp[2][j][i] = Math.max(dp[2][j][i-1] , dp[1][j-1][i-1]);  
                }  
            }else{  
                for (int j = 1; j <= move+1; j++) {  
                    if(i == 1 && j == 1) continue;  
                    // 자두는 1번 자두나무 아래에 위치해 있다고 한다. 이 문제 조건 때문에 1 번만 초기화하기 위해서 2인 경우엔 생략하는 조건문을 추가했다.  
  
                    dp[2][j][i]  = Math.max(dp[2][j][i-1] + 1, dp[1][j-1][i-1] + 1);  
                    dp[1][j][i]  = Math.max(dp[1][j][i-1] , dp[2][j-1][i-1]);  
                }  
            }  
        }  
  
        int answer = 0;  
  
        for (int i = 1; i < 3; i++) {  
            answer = Math.max(dp[i][move + 1][n], answer);  
        }  
  
        System.out.println(answer);  
  
        return;    }  
}
```