https://www.acmicpc.net/problem/2583

```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
    public static int bfs(char[][] map, int x, int y) {  
        Queue<int[]> q = new LinkedList<>();  
        q.add(new int[]{x, y});  
        map[x][y] = '1';  
        int[] dx = {0, 0, -1, 1};  
        int[] dy = {1, -1, 0, 0};  
        int area = 1;  
  
        while (!q.isEmpty()) {  
            int[] c = q.poll();  
            for (int i = 0; i < 4; i++) {  
                int nx = c[0] + dx[i];  
                int ny = c[1] + dy[i];  
  
                if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length || map[nx][ny] == '1')  
                    continue;  
                area++;  
                map[nx][ny] = '1';  
                q.add(new int[]{nx, ny});  
            }  
        }  
        if(area % 4 != 0) area++;  
        return area / 4;  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int n = Integer.parseInt(st.nextToken()) * 2;  
        int m = Integer.parseInt(st.nextToken()) * 2;  
        int t = Integer.parseInt(st.nextToken());  
        char[][] map = new char[n][m];  
  
        for (int i = 0; i < t; i++) {  
            String[] s = br.readLine().split(" ");  
            int[] ld = new int[2];  
            int[] rt = new int[2];  
  
            for (int j = 0; j < 2; j++) {  
                ld[j] = Integer.parseInt(s[j]) * 2;  
            }  
            for (int j = 0; j < 2; j++) {  
                rt[j] = Integer.parseInt(s[j + 2]) * 2;  
            }  
  
            for (int j = ld[0]; j < rt[0]; j++) {  
                for (int k = ld[1]; k <rt[1]; k++) {  
                    map[k][j] = '1';  
                }  
            }  
        }  
        for (int i = 0; i < map.length; i++) {  
            System.out.println(Arrays.toString(map[i]));  
        }  
  
        int d = 0;  
        List<Integer> ans = new ArrayList<>();  
  
        for (int i = 0; i < n; i++) {  
            for (int j = 0; j < m; j++) {  
                if (map[i][j] != '1') {  
                    d++;  
                    ans.add(bfs(map, i, j));  
                }  
            }  
        }  
        StringBuilder sb = new StringBuilder();  
        sb.append(d).append("\n");  
        ans.sort(Integer::compareTo);  
        ans.forEach((i) -> sb.append(i).append(" "));  
        System.out.println(sb);  
        return;    }  
}

```
좌표평면을 2배 스케일로 늘려서 풀이하는 법이 중요했다!!!
그리고 평면을 2배 늘렸으니 넓이는 4배로 나누어 주는 로직이 중요함



https://www.acmicpc.net/problem/5014
```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int f = Integer.parseInt(st.nextToken());  
        int s = Integer.parseInt(st.nextToken());  
        int g = Integer.parseInt(st.nextToken());  
        int u = Integer.parseInt(st.nextToken());  
        int d = Integer.parseInt(st.nextToken());  
  
        int [] v = new int[f+1];  
        Arrays.fill(v, Integer.MAX_VALUE);  
  
        v[s] = 0;  
        int ans = Integer.MAX_VALUE;  
  
        Queue<int[]> q = new LinkedList<>();  
        q.add(new int[]{s,0});  
  
        int[] ud = new int[]{u,d};  
  
        while(!q.isEmpty()){  
  
            int[] c = q.poll();  
  
            for (int i = 0; i < 2; i++) {  
  
                int ns = c[0];  
                if(i == 0) ns += ud[i];  
                if(i == 1) ns -= ud[i];  
  
                int nc = c[1] + 1;  
                if(ns <= 0 || ns > f || v[ns] < nc)  
                    continue;  
                v[ns] = nc;  
                if(ns == g){  
                    ans = nc;  
                    break;                }  
                q.add(new int[]{ns, nc});  
            }  
        }  
  
        if(ans == Integer.MAX_VALUE){  
            System.out.println("use the stairs");  
            return;        }  
  
        System.out.println(ans);  
        return;    }  
}

```

메모리 초과
위의 문제를 BFS 로 접근했을 때 메모리 초과가 발생했다.  내 생각에 그 이유는  이미 방문한 곳을 방문할 수 있는 로직이었다. 다른 최솟값을 가지는 경로는 존재하지 않는다.

또한 내가 틀린 사소한 이유는 처음 부터 목적지와 층수가 같은 경우에 위의 코드에서는 이미 큐에 삽입하고 새로운 좌표를 up down 으로 구하기 때문에 바로 잡아낼 수 없다. 따라서 큐에 꺼내자마 시작지와 목적지가 같은지 확인하도록 바꾸던지 아니면 while 문 시작하기 전에 거를 수 있어야한다.

```java
int[] c = q.poll();  
if(c[0] == g){  
    ans = c[1];  
    break;
}
```
위처럼 바꾸든 아니라면

```java
 if(s == g){
            System.out.println(0);
            return;
        }

```

그리고 아파트는 0 층이 허용이 안되기 때문에 아래와 같이 바꿔야한다.

```
  
if(ns <= 0 || ns > f || v[ns] == true)  
    continue;
```





https://www.acmicpc.net/problem/2468

```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
    public static void bfs(int x, int y, int[][] map, int z, boolean[][] v){  
        Queue<int[]> q = new LinkedList<>();  
        q.add(new int[]{x,y});  
        v[x][y] = true;  
  
        int[] dx  = {1,-1,0,0};  
        int[] dy = {0,0,1,-1};  
  
        while(!q.isEmpty()){  
            int[] c = q.poll();  
            for (int i = 0; i < 4; i++) {  
                int nx = c[0] + dx[i];  
                int ny = c[1] + dy[i];  
                if(nx < 0 || nx >= map.length || ny < 0 || ny >= map.length||  
                        map[nx][ny] <= z || v[nx][ny] == true)  
                    continue;  
                v[nx][ny] = true;  
                q.add(new int[]{nx,ny});  
            }  
        }  
    }  
    public static int getCount(int x, int[][] map){  
        int result = 0;  
        boolean[][] v = new boolean[map.length][map.length];  
  
        for (int i = 0; i < map.length; i++) {  
            for (int j = 0; j < map.length; j++) {  
                if(map[i][j] > x && v[i][j] != true){  
                    result++;  
                    bfs(i,j,map,x,v);  
                }  
            }  
        }  
        return result;  
    }  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        int[][] map = new int[n][n];  
  
        int max = Integer.MIN_VALUE;  
        int min = Integer.MAX_VALUE;  
  
        for (int i = 0; i < n; i++) {  
            String[] s = br.readLine().split(" ");  
            for (int j = 0; j < s.length; j++) {  
                int tmp = Integer.parseInt(s[j]);  
                map[i][j] = tmp;  
                max = Math.max(max,tmp);  
                min = Math.min(min, tmp);  
            }  
        }  
        int ans = Integer.MIN_VALUE;  
        for (int i = 0; i <= 100; i++) {  
            ans = Math.max(ans,getCount(i,map));  
        }  
  
        if(ans == Integer.MIN_VALUE) ans = 0;  
        System.out.println(ans);  
        return;    }  
}

```

위는 정답 코드이다 비의 량을 0 에서 100 까지 수행 했을 때이다. 초기에는 방파제의 높이가 가장 작은 것부터 가장 큰것 까지의 범위만을 수행했었는데 틀렸다.

```java
  for (int i = min; i <= max; i++) {  
            ans = Math.max(ans,getCount(i,map));  
        }  

```

위처럼 수행했는데 생각해보니 만일 Min 과 max 가 1 로 같다고 가정해보면 비가 0 일 때는 잠기지 않는 예외의 경우가 생기지만 min 과 동일하게 비가 내린다면 안전범위의 넓이가 0이개 된다 따라서 0 부터 탐색을 해야했다.
