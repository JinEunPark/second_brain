
https://www.acmicpc.net/problem/2573
```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.function.Consumer;  
  
class Main {  
    static int melted = 0;  
    public static int getCount(int[][] map){  
        int count = 0;  
        boolean[][] v = new boolean[map.length][map[0].length];  
        for (int i = 0; i < map.length; i++) {  
            for (int j = 0; j < map[0].length; j++) {  
                if(!v[i][j] && map[i][j] != 0){  
                    bfs(map,i,j,v);  
                    count++;  
                }  
            }  
        }  
        return count;  
    }  
  
    public static void bfs(int[][] map, int x, int y, boolean[][] v){  
        v[x][y] = true;  
        Queue<int[]> q = new LinkedList<>();  
        q.add(new int[]{x,y});  
  
        int[] dx = {0,0,1,-1};  
        int[] dy = {1,-1,0,0};  
  
        while(!q.isEmpty()){  
  
            int[] c = q.poll();  
  
            for (int i = 0; i < 4; i++) {  
                int nx = dx[i] + c[0];  
                int ny = dy[i] + c[1];  
  
                if(nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length  
                        || v[nx][ny] || map[nx][ny] == 0)  
                    continue;  
                v[nx][ny] = true;  
                q.add(new int[]{nx,ny});  
            }  
        }  
    }  
  
    public static void year(int[][] map) {  
        int[] dx = {0, 0, -1, 1};  
        int[] dy = {1, -1, 0, 0};  
        Queue<int[]> q = new LinkedList<>();  
  
        for (int i = 0; i < map.length; i++) {  
            for (int j = 0; j < map[0].length; j++) {  
                if (map[i][j] == 0) {  
                    for (int k = 0; k < 4; k++) {  
                        int nx = i + dx[k];  
                        int ny = j + dy[k];  
  
                        if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length  
                                || map[nx][ny] == 0)  
                            continue;  
                        q.add(new int[]{nx, ny});  
                    }  
                }  
            }  
        }  
  
        q.stream().forEach((c)->{  
            if(map[c[0]][c[1]] != 0){  
                map[c[0]][c[1]] = map[c[0]][c[1]] -1;  
                if(map[c[0]][c[1]] == 0){  
                    ++ melted;  
                }  
            }  
        });  
    }  
    public static void main(String[] args) throws IOException {  
  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        int m = Integer.parseInt(st.nextToken());  
  
        int[][] map = new int[n][m];  
        int max_g = 0;  
  
        for (int i = 0; i < n; i++) {  
            String[] s = br.readLine().split(" ");  
  
            for (int j = 0; j < m; j++) {  
                int tmp = Integer.parseInt(s[j]);  
                if(tmp == 0) ++ melted;  
                if(max_g < tmp) max_g = tmp;  
                map[i][j] = tmp;  
            }  
        }  
  
        if(max_g == 0){  
            System.out.println("0");  
            return;        }  
  
        int ans = 0;  
        int time = 0;  
  
        if(2 <= getCount(map)){  
            System.out.println(ans);  
            return;        }  
  
        while(true) {  
            if(melted == n*m)  
                break;  
  
  
            time++;  
            year(map);  
  
            if(2 <= getCount(map)){  
                ans = time;  
                break;            }  
        }  
  
        System.out.println(ans);  
        return;    }  
}

```

내가 틀린 부분은 time 변수를 어디까지 늘려야 하냐 였다. 처음에는 최대 년수 많큼만 수행하면 모든 빙하가 녹을 것으로 생각했지해 최대의 빙하 크기를 구하는 로직했었다. 하지만 문제의 조건에서  바다 근처만 빙하가 녹으니 가장 중앙에 있는 빙하는 10 년이 지나도 녹지 않을 수 있었댜.

이를 다시 올바르게 계산하기 위해선 녹은 빙하의 수를 세어야한다. 따라서 

```java
q.stream().forEach((c)->{  
    if(map[c[0]][c[1]] != 0){  
        map[c[0]][c[1]] = map[c[0]][c[1]] -1;  
        if(map[c[0]][c[1]] == 0){  
            ++ melted;  
        }  
    }  
});

```

위와 같이 0 을 새어주는 로직을 추가했다.

그리고 처음에 틀렸던 이유는 빙하가 녹는 동시성이다. 코드를 짤때 1년차에 1 이었다가 0 이된 수가  다시  반복문을 통해서 0년차에 0 으로 인식되어서 추가로 주위의 빙하를 녹여버리는 오류가 생겼다 이를 한번에 처리하기 위해서 year 코드를 0 인지점의 사방을 큐에 삼입하고 삽입되어진 좌표의 숫자를 한번에 반영하도록 했다.
코드는 다음과 같다.

```java
public static void year(int[][] map) {  
    int[] dx = {0, 0, -1, 1};  
    int[] dy = {1, -1, 0, 0};  
    Queue<int[]> q = new LinkedList<>();  
  
    for (int i = 0; i < map.length; i++) {  
        for (int j = 0; j < map[0].length; j++) {  
            if (map[i][j] == 0) {  
                for (int k = 0; k < 4; k++) {  
                    int nx = i + dx[k];  
                    int ny = j + dy[k];  
  
                    if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length  
                            || map[nx][ny] == 0)  
                        continue;  
                    q.add(new int[]{nx, ny});  //바로 반영하지 않고 큐에 삽입
                }  
            }  
        }  
    }  
  
    q.stream().forEach((c)->{  //추후 동시에 반영
        if(map[c[0]][c[1]] != 0){  
            map[c[0]][c[1]] = map[c[0]][c[1]] -1;  
            if(map[c[0]][c[1]] == 0){  
                ++ melted;  
            }  
        }  
    });  
}

```

https://www.acmicpc.net/problem/14442

```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.function.Consumer;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        int m = Integer.parseInt(st.nextToken());  
        int k = Integer.parseInt(st.nextToken());  
        int[][] map = new int[n][m];  
  
        for (int i = 0; i < n; i++) {  
            char[] s = br.readLine().toCharArray();  
            for (int j = 0; j < m; j++) {  
                map[i][j] = Character.getNumericValue(s[j]);  
            }  
        }  
        int answer = Integer.MAX_VALUE;  
  
        boolean[][][] v = new boolean[n][m][k+1];  
        int[] dx = {1, -1, 0, 0};  
        int[] dy = {0, 0, -1, 1};  
  
        int[] dx2 = {2, -2, 0, 0};  
        int[] dy2 = {0, 0, -2, 2};  
  
        Queue<int[]> q = new LinkedList<>();  
        q.add(new int[]{0, 0, 0, 1});  
        v[0][0][0] = true;  
  
        while (!q.isEmpty()) {  
  
            int[] c = q.poll();  
            if (c[0] == n - 1 && c[1] == m - 1) {  
                answer = Math.min(answer,c[3]);  
            }  
  
            for (int i = 0; i < 4; i++) {  
  
                int nx = dx[i] + c[0];  
                int ny = dy[i] + c[1];  
                int jump = c[2];  
  
  
                if (nx >= 0 && nx < n && ny >= 0 && ny < m ){  
  
                    if(!v[nx][ny][jump] && map[nx][ny] == 0){  
                        v[nx][ny][jump] = true;  
                        q.add(new int[]{nx, ny, jump, c[3] + 1});  
                    }  
  
                    if(jump < k && !v[nx][ny][jump + 1] && map[nx][ny] == 1){  
                        v[nx][ny][jump + 1] = true;  
                        q.add(new int[]{nx, ny, jump + 1, c[3] + 1});  
                    }  
                }  
  
            }  
        }  
        if(answer == Integer.MAX_VALUE) answer = -1;  
        System.out.println(answer);  
        return;    }  
}

```

초기엔 벽을 부수고 뛰어넘어가는 로직으로 잘못생각해서 정말 많이 틀렸다 알고보니 한칸을 뛰어넘는 로직이 아니라 벽을 부수고 해당 벽 칸으로 이동하는 로직이었다.


https://www.acmicpc.net/problem/16933
```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        int m = Integer.parseInt(st.nextToken());  
        int k = Integer.parseInt(st.nextToken());  
  
        int[][] map = new int[n][m];  
  
        for (int i = 0; i < n; i++) {  
            char[] ch = br.readLine().toCharArray();  
            for (int j = 0; j < m; j++) {  
                map[i][j] = ch[j] - '0';  
            }  
        }  
  
        int answer = Integer.MAX_VALUE;  
        int[] dx = {1, -1, 0, 0};  
        int[] dy = {0, 0, 1, -1};  
  
        boolean[][][][] v = new boolean[n][m][k + 1][2];  
        v[0][0][0][0] = true;  
  
        Queue<int[]> q = new LinkedList<>();  
        q.add(new int[]{0, 0, 0, 1});  
  
        while (!q.isEmpty()) {  
            int[] c = q.poll();  
            if (c[0] == n - 1 && c[1] == m - 1) {  
                answer = c[3];  
                break;            }  
  
            for (int i = 0; i < 4; i++) {  
                int nx = dx[i] + c[0];  
                int ny = dy[i] + c[1];  
                int jc = c[2];  
                int dis = c[3] + 1;  
  
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {  
                    if (map[nx][ny] == 0 && !v[nx][ny][jc][dis % 2]) {  
                        v[nx][ny][jc][dis % 2] = true;  
                        q.add(new int[]{nx, ny, jc, dis});  
                    }  
  
                    if (map[nx][ny] == 1 && c[3] % 2 == 1 && jc < k && !v[nx][ny][jc + 1][dis % 2]) {  
  
                        v[nx][ny][jc + 1][dis % 2] = true;  
                        q.add(new int[]{nx, ny, jc + 1, dis});  
                    }  
                    //다음 가려는 곳이 벽인데 현재가 밤일 때 하루더 기다리는 경우  
                    if(map[nx][ny] == 1 && c[3] % 2 == 0 && !v[c[0]][c[1]][c[2]][(c[3] + 1) % 2] && jc < k){  
                        v[c[0]][c[1]][c[2]][(c[3] + 1) % 2] = true;  
                        q.add(new int[]{c[0], c[1], c[2], c[3] + 1});  
                    }  
                }  
            }  
        }  
        if (answer == Integer.MAX_VALUE) answer = -1;  
        System.out.println(answer);  
        return;    }  
}

```

시간 초과가 발생했다 문제에서 낮과 밤이라는 조건이 있어서 같은 좌표를 낮에 방문한 경우와 밤에 방문한경우로 나누었다. 하지만 시간 초과가 발생했다. 낮과 밤을 나누어서 방문 처리를 해주었는데 이러면 map 의 크기가 2,000,000 과 같아져서 그런거 같다. 빅오 표기법으로 계산하면 2 천만 정도로 충분히 연산이 가능한 정도이다.

하여간 그래서 낮과 밤을 따로 계산하지 않고 낮과 밤은 거리를 나머지 연산한 것으로 퉁쳐서 계산했다.
```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        int m = Integer.parseInt(st.nextToken());  
        int k = Integer.parseInt(st.nextToken());  
  
        int[][] map = new int[n][m];  
  
        for (int i = 0; i < n; i++) {  
            char[] ch = br.readLine().toCharArray();  
            for (int j = 0; j < m; j++) {  
                map[i][j] = ch[j] - '0';  
            }  
        }  
  
        int answer = Integer.MAX_VALUE;  
        int[] dx = {1, -1, 0, 0};  
        int[] dy = {0, 0, 1, -1};  
  
        boolean[][][] v = new boolean[n][m][k + 1];  
        v[0][0][0] = true;  
  
        Queue<int[]> q = new LinkedList<>();  
        q.add(new int[]{0, 0, 0, 1});  
  
        while (!q.isEmpty()) {  
            int[] c = q.poll();  
            if (c[0] == n - 1 && c[1] == m - 1) {  
                answer = c[3];  
                break;            }  
  
            for (int i = 0; i < 4; i++) {  
                int nx = dx[i] + c[0];  
                int ny = dy[i] + c[1];  
                int jc = c[2];  
                int dis = c[3] + 1;  
  
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {  
                    if (map[nx][ny] == 0 && !v[nx][ny][jc]) {  
                        v[nx][ny][jc] = true;  
                        q.add(new int[]{nx, ny, jc, dis});  
                    }  
  
                    if (map[nx][ny] == 1 && c[3] % 2 == 1 && jc < k && !v[nx][ny][jc + 1]) {  
  
                        v[nx][ny][jc + 1] = true;  
                        q.add(new int[]{nx, ny, jc + 1, dis});  
                    }  
                    //다음 가려는 곳이 벽인데 현재가 밤일 때 하루더 기다리는 경우  
                    if(map[nx][ny] == 1 && c[3] % 2 == 0 && v[c[0]][c[1]][c[2]] && jc < k){  
                        v[c[0]][c[1]][c[2]] = true;  
                        q.add(new int[]{c[0], c[1], c[2], c[3] + 1});  
                    }  
                }  
            }  
        }  
        if (answer == Integer.MAX_VALUE) answer = -1;  
        System.out.println(answer);  
        return;    }  
}

```


```
        boolean[][][] v = new boolean[n][m][k + 1];  
```

방문 배열을 3차원으로 계산했다. 이걸로도 충분하게 통과가 가능한 수준이다 하지만 이를 한번더 최적화 하면 더 적은 차원의 방문체크 만으로도  수행이 가능하다.


https://www.acmicpc.net/problem/16920
해당 문제의 주요 포인트는 한번에 특정 거리, 특정 플레이어 만큼의 BFS 의 수행이다. 이를 위해서 발상의 전환이 필요한데 바로 플레이어의 수만큼의 큐를 이용하는 것이다. 따라서 9 명이라면 9개의 큐가 필요한것이다.

```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.stream.Collectors;  
  
class Main {  
  
    public static int operTurn(char[][] map, Queue<int[]> q, boolean[][] v, int dis) {  
  
        int n = map.length;  
        int m = map[0].length;  
  
        int[] dx = {0, 0, 1, -1};  
        int[] dy = {1, -1, 0, 0};  
  
        int count = 0; //채워진 빈자리의 갯수  
        int distance = 0; //거리  
  
        while (!q.isEmpty()) {  
            int size = q.size();  
            for (int k = 0; k < size; k++) {//현재 큐에 존재하는 노드 수만큼 반복  
                int[] c = q.poll();  
                for (int i = 0; i < 4; i++) {  
                    int nx = c[0] + dx[i];  
                    int ny = c[1] + dy[i];  
                    if (nx < 0 || nx >= n || ny < 0 || ny >= m || map[nx][ny] == '#' || v[nx][ny])  
                        continue;  
                    v[nx][ny] = true;  
                    if (map[nx][ny] == '.') {  
                        count++;  
                        map[nx][ny] = (char) (c[2] + '0');  
                        q.add(new int[]{nx, ny, c[2]});  
                    }  
                }  
            }  
            distance++;  
            if(distance >= dis) break;//Si 번째 거리보다 크다면 종료  
  
        }  
  
        return count;  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        int m = Integer.parseInt(st.nextToken());  
        int p = Integer.parseInt(st.nextToken());  
        String[] s = br.readLine().split(" ");  
        int blank = 0;  
        int[] si = Arrays.stream(s).mapToInt(Integer::parseInt).toArray();//거리 배열 생성  
        char[][] map = new char[n][m];  
  
        for (int i = 0; i < n; i++) {  
            map[i] = br.readLine().toCharArray();  
        }  
  
        Queue<int[]>[] queues = new Queue[p + 1];//플레이어 수만큼의 배열 생성  
        for (int i = 0; i < p; i++) {  
            queues[i] = new LinkedList<>();  
        }  
  
        for (int i = 0; i < n; i++) {  
            for (int j = 0; j < m; j++) {  
                if (map[i][j] != '.' && map[i][j] != '#') {  
                    queues[map[i][j] - '0' - 1].offer(new int[]{i, j, map[i][j] - '0'});// 플레이어 큐에 거리 추가  
                }  
                if (map[i][j] == '.') blank++;  
            }  
        }  
  
        boolean[][] v = new boolean[n][m];  
        while (blank != 0) {  
            int tmp = blank;  
            for (int i = 0; i < p; i++) {  
                blank -= operTurn(map, queues[i], v, si[i]);//BFS 수행  
            }  
            if(tmp == blank) break;//모든 플레이어가 차례를 지났는데 빈칸에 변화가 없다면 종료  
        }  
  
        List<Integer> answers = new ArrayList<>();  
        for (int i = 0; i <= p; i++) {  
            answers.add(0);  
        }  
  
        for (int i = 0; i < n; i++) {  
            for (int j = 0; j < m; j++) {  
                if (map[i][j] != '#' && map[i][j] != '.') {  
                    answers.set(map[i][j] - '0', answers.get(map[i][j] - '0') + 1);//성의 수 새기  
                }  
            }  
        }  
  
        StringBuilder sb = new StringBuilder();  
        for (int i = 1; i <= p; i++) {  
            sb.append(answers.get(i)).append(" ");  
        }  
  
        System.out.println(sb);  
        return;  
  
    }  
}

```

이 문제는 무조건 다시 풀어야겠다.


https://www.acmicpc.net/problem/11967

```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.stream.Collectors;  
  
class Main {  
  
    static int answer = 1;  
    public static int lightUp(int[][] map, int[] c, Map<String, List<int[]>> lmap) { //불을 키는 과정  
        int count = 0;  
  
        String key = c[0] + " " + c[1];  
        if (lmap.get(key) == null) return 0;  
        for (int[] i : lmap.get(key)) {  
            if (map[i[0]][i[1]] == 0) { // 아직 불을 키지 않은 방이지만 불을 켜야할 때  
                map[i[0]][i[1]] = 1;  
                count++;  
            }  
        }  
        return count;  
    }  
  
    public static void bfs(int[][] map, boolean[][] v, Map<String, List<int[]>> lmap){  
  
  
        Queue<int[]> q = new LinkedList<>();  
        q.add(new int[]{1, 1});  
        v[1][1] = true;  
        map[1][1] = 1;  
        int tmp = answer;  
  
        int n = map.length - 1;  
        int[] dx = {0, 0, 1, -1};  
        int[] dy = {1, -1, 0, 0};  
  
        boolean r = false;  
        while (!q.isEmpty()) {  
            int[] c = q.poll();  
            answer += lightUp(map, c, lmap);  
  
            for (int i = 0; i < 4; i++) {  
                int nx = c[0] + dx[i];  
                int ny = c[1] + dy[i];  
  
                if(nx < 1 || nx > n || ny < 1 || ny > n || map[nx][ny] == 0||v[nx][ny]) // 만일 범위 안에 존재하고 방문하지 않았으면서 불이 켜졌다면 방문  
                    continue;  
                v[nx][ny] = true;  
                q.add(new int[]{nx,ny});  
            }  
        }  
  
        if(answer != tmp) bfs(map,new boolean[n+1][n+1], lmap);  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int n = Integer.parseInt(st.nextToken());  
        int m = Integer.parseInt(st.nextToken());  
        int[][] map = new int[n + 1][n + 1];  
        boolean[][] v = new boolean[n + 1][n + 1];  
        Map<String, List<int[]>> lmap = new HashMap<>();  
  
        for (int i = 0; i < m; i++) {  
            String[] s = br.readLine().split(" ");  
            int t1 = Integer.parseInt(s[0]);  
            int t2 = Integer.parseInt(s[1]);  
            int t3 = Integer.parseInt(s[2]);  
            int t4 = Integer.parseInt(s[3]);  
            String key = t1 + " " + t2;  
            lmap.putIfAbsent(key, new ArrayList<>());  
            lmap.get(key).add(new int[]{t3, t4});  
        }  
  
        bfs(map,v,lmap);  
  
        System.out.println(answer);  
        return;    }  
}
```


이 문제를 풀면서 가장 애먹었던 부분은 이미 방문한 노드에서 불이 켜진 노드가 생겨서 방문 가능해진 노드의 처리였다.

1. 해당 노드에서 킬수 있는 불을 모두 켠다
2. 1번 과정에서 켜진 불이 있다면 처음 부터 탐색을 다시한다.

최악의 경우 10000 번의 연산이 생기지만 충분히 가능하다.

문제에 대한 간단 설명
해당 방에서 스위치를 이용해 다른 방의 불을 킬 수 있고 사람은 불켜진 방만을 방문 가능할 때다
여기서 문제점은 이미 탐색이 끝난 노드에 대해서 불이 켜짐으로서 방분 가능해진 경우이다.


| 1   | 2   | 3   |
| --- | --- | --- |
| 4   | 5   | 6   |
|     |     |     |
예를 들어서 1번의 인접한 노드를 모두 탐색후 3번으로 갔는데 3번에 4 번에 대한 스위치가 있을 경우 이를 다시 탐색해야한다.
초기에는 DFS 로 불을 켜서 한번에 수행하려 했는데 너무 복잡해졌다....


https://www.acmicpc.net/problem/9328
백준 열쇠

```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.stream.Collectors;  
  
class Main {  
  
    static List<int[]> findKeys(Set<Character> keySet, char[][] map) {  
        List<int[]> enters = new ArrayList<>();  
  
        for (int i = 0; i < map.length; i++) {  
            if (map[i][0] == '.' ||  
                    (Character.isAlphabetic(map[i][0]) &&  
                        (keySet.contains(Character.toLowerCase(map[i][0])) ||  
                        Character.isLowerCase(map[i][0]))  
                    )) { //왼 세로  
                enters.add(new int[]{i, 0});  
            }  
            if (map[i][map[0].length - 1] == '.' ||  
                    (Character.isAlphabetic(map[i][map[0].length - 1]) &&  
                            (keySet.contains(Character.toLowerCase(map[i][map[0].length - 1]))||  
                            Character.isLowerCase(map[i][0]))  
                    )) { //오른 세로로  
                enters.add(new int[]{i, map[0].length - 1});  
            }  
        }  
  
        for (int i = 1; i < map[0].length - 1; i++) {  
            if (map[0][i] == '.' ||  
                    (Character.isAlphabetic(map[0][i]) &&  
                            (keySet.contains(Character.toLowerCase(map[0][i]))||  
                            Character.isLowerCase(map[0][i]))  
                    )) {  
                enters.add(new int[]{0, i});  
            }  
            if (map[map.length - 1][i] == '.' ||  
                    (Character.isAlphabetic(map[map.length - 1][i]) &&  
                            (keySet.contains(Character.toLowerCase(map[map.length - 1][i])) ||  
                            Character.isLowerCase(map[map.length - 1][i])  
                            ))) {  
                enters.add(new int[]{map.length - 1, i});  
            }  
        }  
  
        //겉 부분 키 거르기  
        enters.forEach((i)->{  
            if(Character.isAlphabetic(map[i[0]][i[1]])  
                    && Character.isLowerCase(map[i[0]][i[1]]))  
                keySet.add(map[i[0]][i[1]]);  
        });  
        return enters;  
    }  
  
    static void bfs(char[][] map, boolean[][] v, List<int[]> enters, Set<Character> keySet, Set<String> paperSet) {  
        int paper = 0;  
        int[] dx = {1,-1,0,0};  
        int[] dy = {0,0,1,-1};  
  
        Queue<int[]> q = new LinkedList<>();  
        enters.forEach((i)->{  
            q.add(i);  
            v[i[0]][i[1]] = true;  
        });  
  
        while(!q.isEmpty()){  
            int[] c = q.poll();  
            for (int i = 0; i < 4; i++) {  
                int nx = c[0] + dx[i];  
                int ny = c[1] + dy[i];  
  
                if(nx < 0 || nx >= map.length || ny < 0|| ny >= map[0].length || map[nx][ny] == '*'|| v[nx][ny])  
                    continue;  
                if(Character.isAlphabetic(map[nx][ny]) && Character.isLowerCase(map[nx][ny])){  
                    keySet.add(map[nx][ny]);  
                }  
  
                if(Character.isAlphabetic(map[nx][ny])  
                        && Character.isUpperCase(map[nx][ny])  
                        && !keySet.contains(Character.toLowerCase(map[nx][ny])))  
                    continue;  
                if(!paperSet.contains(nx + " " + ny) && map[nx][ny] == '$'){  
                    paperSet.add(nx + " " + ny);  
                    paper++;  
                }  
                v[nx][ny] = true;  
                q.add(new int[]{nx,ny});  
            }  
        }  
  
        return ;  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        StringBuilder sb = new StringBuilder();  
        int test = Integer.parseInt(st.nextToken());  
  
        for (int i = 0; i < test; i++) {  
            st = new StringTokenizer(br.readLine());  
            int n = Integer.parseInt(st.nextToken());  
            int m = Integer.parseInt(st.nextToken());  
            char[][] map = new char[n][m];  
  
            for (int j = 0; j < n; j++) {  
                map[j] = br.readLine().toCharArray();  
            }  
  
            Set<Character> keySet = new HashSet<>();  
            char[] keyArray = br.readLine().toCharArray();  
            if(keyArray[0] != '0'){  
                for (int j = 0; j < keyArray.length; j++) {  
                    keySet.add(keyArray[j]);  
                }  
            }  
  
  
            List<int[]> enters = findKeys(keySet, map);  
            Set<String> paperSet = new HashSet<>();  
            while(true){  
                int ps = paperSet.size();  
                int ks = keySet.size();  
                enters = findKeys(keySet,map);  
                bfs(map,new boolean[n][m],enters,keySet,paperSet);  
                if(ks == keySet.size())  
                    break;  
            }  
            sb.append(paperSet.size()).append("\n");  
        }  
        System.out.println(sb);  
        return;    }  
}
```

음 일단 처음에 BFS 를 시작할 수 있는 입구를 찾기 위한 로직을 설계했다. 모든 테두리를 훑어서 들어갈 수 있다면 그 부분을 큐에 삽입했다.
- 열쇠가 있는 문이거나
- 그냥 뚤려있거나 
그래서 BFS 도중에 열쇠를 찾는다면 다시 BFS 순회를 처음 부터하는 로직을 만들었는데 틀렸다. 생각을 해보니 불확실한 종료 조건이 문제인거 같다.

**정답코드**

```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.stream.Collectors;  
  
class Main {  
  
  
    static int bfs(char[][] map, boolean[][] v, Map<Character,List<int[]>> doorMap, Set<Character> keySet) {  
        int paper = 0;  
        int[] dx = {1, -1, 0, 0};  
        int[] dy = {0, 0, 1, -1};  
  
        Deque<int[]> q = new LinkedList<>();  
        q.add(new int[]{0,0});  
        v[0][0] = true;  
  
  
        while (!q.isEmpty()) {  
            int[] c = q.poll();  
            for (int i = 0; i < 4; i++) {  
                int nx = c[0] + dx[i];  
                int ny = c[1] + dy[i];  
  
                if(nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length || v[nx][ny] || map[nx][ny] == '*')  
                    continue;  
                char cur = map[nx][ny];  
                if(Character.isAlphabetic(cur) && Character.isUpperCase(cur)){  
                    if(!keySet.contains(Character.toLowerCase(cur))) {  
                        // 키를 가지고 방문하지 않았을 경우의 방문처리  
                        doorMap.get(Character.toLowerCase(cur)).add(new int[]{nx,ny});  
                        continue;                    }  
                }  
  
                if(Character.isAlphabetic(cur) && Character.isLowerCase(cur)){//키를 방문한경우  
                    v[nx][ny] = true;  
                    q.add(new int[]{nx, ny});  
                    if(!keySet.contains(cur)){//키를 가지고 있지 않은데 새로운 키를 찾았다면 그간에 방문했던 모든 문들 넣어주기  
                        keySet.add(cur);  
                        List<int[]> doors = doorMap.get(cur);  
                        for (int[] door : doors) {  
                            v[door[0]][door[1]] = true;  
                            q.offer(new int[]{door[0],door[1]});//방문처리후 삽입  
                        }  
                    }  
                    continue;  
                }  
  
                if(cur == '$') {  
                    paper++;  
                }  
  
                v[nx][ny] = true;  
                q.add(new int[]{nx, ny});  
            }  
        }  
  
        return paper;  
    }  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        StringBuilder sb = new StringBuilder();  
        int test = Integer.parseInt(st.nextToken());  
  
        for (int i = 0; i < test; i++) {  
            st = new StringTokenizer(br.readLine());  
            int n = Integer.parseInt(st.nextToken());  
            int m = Integer.parseInt(st.nextToken());  
            char[][] map = new char[n + 2][m + 2];  
  
            for (int j = 0; j < n + 2; j++) {  
                Arrays.fill(map[j],'.');  
            }  
  
            for (int j = 1; j < n + 1; j++) {  
                char[] tmp = br.readLine().toCharArray();  
                for (int k = 1; k < m + 1; k++) {  
                    map[j][k] = tmp[k-1];  
                }  
            }  
  
  
            Set<Character> keySet = new HashSet<>();  
            Map<Character, List<int[]>> doorMap = new HashMap<>();//방문한 곳에 문이 있는 좌표 저장.  
  
            char[] keyArray = br.readLine().toCharArray();  
            if (keyArray[0] != '0') {  
                for (int j = 0; j < keyArray.length; j++) {  
                    keySet.add(keyArray[j]);  
                }  
            }  
            char tmpKey = 'a';  
            for (int j = 0; j < 26; j++) {  
  
                doorMap.put((char)(tmpKey + j),new ArrayList<>());  
            }  
  
  
            int answer = bfs(map,new boolean[n+2][m+2],doorMap,keySet);  
            sb.append(answer).append('\n');  
        }  
        System.out.println(sb);  
        return;   
         }  
}
```

실수 했던 부분
```java
if(Character.isAlphabetic(cur) && Character.isUpperCase(cur)){  
                    if(!keySet.contains(Character.toLowerCase(cur))) {  
                        // 키를 가지고 방문하지 않았을 경우의 방문처리  
                        doorMap.get(Character.toLowerCase(cur)).add(new int[]{nx,ny});  
                        continue;                    }  
                }  

```
- 현재 cur 이 대문자일 때 이에 해당하는 문을 만났다는 것
- 그러니 현재 이 문에대한 키를 가지고 있다면 doormap 에 삽입해서 다른 키에 해당하는 문을 찾을 수 있도록 삽입하는 과정이다
- 이 때 현재 문자가 대문자이기 때문에 소문자로 변경하는 로직을 생략해서 절대 키를 가지고 있는 경우를 탐색할 수없었다. 조심할것

**풀이**
이문제를 풀이하기 위해서 주의해야할 점은 키를 찾은 후의 동작이다.
먼저 키를 만난경우 
1. 키를 이미 가지고 있던 경우 해당 칸을 빈칸취급해 큐에 삽입한다
2. 키를 가지고 있지 않은 경우에 이미 방문한 문들중 키가 존재하지 않아서 들어갈 수 없던 경로를 모두 큐에 