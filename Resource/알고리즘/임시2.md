https://www.acmicpc.net/problem/2583





https://www.acmicpc.net/problem/5014
```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int f = Integer.parseInt(st.nextToken());  
        int s = Integer.parseInt(st.nextToken());  
        int g = Integer.parseInt(st.nextToken());  
        int u = Integer.parseInt(st.nextToken());  
        int d = Integer.parseInt(st.nextToken());  
  
        int [] v = new int[f+1];  
        Arrays.fill(v, Integer.MAX_VALUE);  
  
        v[s] = 0;  
        int ans = Integer.MAX_VALUE;  
  
        Queue<int[]> q = new LinkedList<>();  
        q.add(new int[]{s,0});  
  
        int[] ud = new int[]{u,d};  
  
        while(!q.isEmpty()){  
  
            int[] c = q.poll();  
  
            for (int i = 0; i < 2; i++) {  
  
                int ns = c[0];  
                if(i == 0) ns += ud[i];  
                if(i == 1) ns -= ud[i];  
  
                int nc = c[1] + 1;  
                if(ns <= 0 || ns > f || v[ns] < nc)  
                    continue;  
                v[ns] = nc;  
                if(ns == g){  
                    ans = nc;  
                    break;                }  
                q.add(new int[]{ns, nc});  
            }  
        }  
  
        if(ans == Integer.MAX_VALUE){  
            System.out.println("use the stairs");  
            return;        }  
  
        System.out.println(ans);  
        return;    }  
}

```

메모리 초과
위의 문제를 BFS 로 접근했을 때 메모리 초과가 발생했다.  내 생각에 그 이유는  이미 방문한 곳을 방문할 수 있는 로직이었다. 다른 최솟값을 가지는 경로는 존재하지 않는다.

또한 내가 틀린 사소한 이유는 처음 부터 목적지와 층수가 같은 경우에 위의 코드에서는 이미 큐에 삽입하고 새로운 좌표를 up down 으로 구하기 때문에 바로 잡아낼 수 없다. 따라서 큐에 꺼내자마 시작지와 목적지가 같은지 확인하도록 바꾸던지 아니면 while 문 시작하기 전에 거를 수 있어야한다.

```java
int[] c = q.poll();  
if(c[0] == g){  
    ans = c[1];  
    break;
}
```
위처럼 바꾸든 아니라면

```java
 if(s == g){
            System.out.println(0);
            return;
        }

```

그리고 아파트는 0 층이 허용이 안되기 때문에 아래와 같이 바꿔야한다.

```
  
if(ns <= 0 || ns > f || v[ns] == true)  
    continue;
```





https://www.acmicpc.net/problem/2468

```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
    public static void bfs(int x, int y, int[][] map, int z, boolean[][] v){  
        Queue<int[]> q = new LinkedList<>();  
        q.add(new int[]{x,y});  
        v[x][y] = true;  
  
        int[] dx  = {1,-1,0,0};  
        int[] dy = {0,0,1,-1};  
  
        while(!q.isEmpty()){  
            int[] c = q.poll();  
            for (int i = 0; i < 4; i++) {  
                int nx = c[0] + dx[i];  
                int ny = c[1] + dy[i];  
                if(nx < 0 || nx >= map.length || ny < 0 || ny >= map.length||  
                        map[nx][ny] <= z || v[nx][ny] == true)  
                    continue;  
                v[nx][ny] = true;  
                q.add(new int[]{nx,ny});  
            }  
        }  
    }  
    public static int getCount(int x, int[][] map){  
        int result = 0;  
        boolean[][] v = new boolean[map.length][map.length];  
  
        for (int i = 0; i < map.length; i++) {  
            for (int j = 0; j < map.length; j++) {  
                if(map[i][j] > x && v[i][j] != true){  
                    result++;  
                    bfs(i,j,map,x,v);  
                }  
            }  
        }  
        return result;  
    }  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        int[][] map = new int[n][n];  
  
        int max = Integer.MIN_VALUE;  
        int min = Integer.MAX_VALUE;  
  
        for (int i = 0; i < n; i++) {  
            String[] s = br.readLine().split(" ");  
            for (int j = 0; j < s.length; j++) {  
                int tmp = Integer.parseInt(s[j]);  
                map[i][j] = tmp;  
                max = Math.max(max,tmp);  
                min = Math.min(min, tmp);  
            }  
        }  
        int ans = Integer.MIN_VALUE;  
        for (int i = 0; i <= 100; i++) {  
            ans = Math.max(ans,getCount(i,map));  
        }  
  
        if(ans == Integer.MIN_VALUE) ans = 0;  
        System.out.println(ans);  
        return;    }  
}

```

위는 정답 코드이다 비의 량을 0 에서 100 까지 수행 했을 때이다. 초기에는 방파제의 높이가 가장 작은 것부터 가장 큰것 까지의 범위만을 수행했었는데 틀렸다.

```java
  for (int i = min; i <= max; i++) {  
            ans = Math.max(ans,getCount(i,map));  
        }  

```

위처럼 수행했는데 생각해보니 만일 Min 과 max 가 1 로 같다고 가정해보면 비가 0 일 때는 잠기지 않는 예외의 경우가 생기지만 min 과 동일하게 비가 내린다면 안전범위의 넓이가 0이개 된다 따라서 0 부터 탐색을 해야했다.


https://www.acmicpc.net/problem/6593

```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
    public static void bfs(int x, int y, int[][] map, int z, boolean[][] v){  
        Queue<int[]> q = new LinkedList<>();  
        q.add(new int[]{x,y});  
        v[x][y] = true;  
  
        int[] dx  = {1,-1,0,0};  
        int[] dy = {0,0,1,-1};  
  
        while(!q.isEmpty()){  
            int[] c = q.poll();  
            for (int i = 0; i < 4; i++) {  
                int nx = c[0] + dx[i];  
                int ny = c[1] + dy[i];  
                if(nx < 0 || nx >= map.length || ny < 0 || ny >= map.length||  
                        map[nx][ny] <= z || v[nx][ny] == true)  
                    continue;  
                v[nx][ny] = true;  
                q.add(new int[]{nx,ny});  
            }  
        }  
    }  
  
    public static boolean compare(int[] x, int[] y){  
        for (int i = 0; i < 3; i++) {  
            if(x[i] != y[i]){  
                return false;  
            }  
        }  
        return true;  
    }  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st;  
        StringBuilder sb = new StringBuilder();  
  
        while(true){  
            String stairs = br.readLine();  
            if(stairs.equals("0 0 0")){  
                break;  
            }  
            st = new StringTokenizer(stairs);  
            int z = Integer.parseInt(st.nextToken());  
            int x = Integer.parseInt(st.nextToken());  
            int y = Integer.parseInt(st.nextToken());  
            char[][][] bd = new char[z][x][y];  
  
            int[] start = new int[3];  
            int[] des = new int[3];  
  
            for (int i = 0; i < z; i++) {  
                for (int j = 0; j < x; j++) {  
  
                    String row = br.readLine();  
  
                    if(row.indexOf('S') != -1){  
                        start[0] = i;  
                        start[1] = j;  
                        start[2] = row.indexOf('S');  
                    }  
  
                    if(row.indexOf('E') != -1){  
                        des[0] = i;  
                        des[1] = j;  
                        des[2] = row.indexOf('E');  
                    }  
  
                    bd[i][j] = row.toCharArray();  
                }  
                br.readLine();  
            }  
  
            int[] dz = {1,-1,0,0,0,0};  
            int[] dx = {0,0,1,-1,0,0};  
            int[] dy = {0,0,0,0,1,-1};  
  
            boolean[][][] v = new boolean[z][x][y];  
            v[start[0]][start[1]][start[2]] = true;  
  
            Queue<int[]> q = new LinkedList<>();  
            q.add(new int[]{start[0],start[1],start[2],0});  
            int ans = 0;  
  
            while(!q.isEmpty()){  
                int[] c = q.poll();  
                if(compare(c,des) ){  
                    ans = c[3];  
                    sb.append("Escaped in "+c[3]+" minute(s).").append("\n");  
                    break;                }  
                for (int i = 0; i < 6; i++) {  
                    int nz = c[0] + dz[i];  
                    int nx = c[1] + dx[i];  
                    int ny = c[2] + dy[i];  
  
                    if(nx <0 || nx >= x || ny < 0 || ny >= y || nz <0 || nz >= z ||  
                        v[nz][nx][ny] || bd[nz][nx][ny] == '#')  
                        continue;  
                    v[nz][nx][ny] = true;  
                    q.add(new int[]{nz,nx,ny,c[3] + 1});  
                }  
  
            }  
            if(ans == 0){  
                sb.append("Trapped!\n");  
            }  
        }  
        System.out.println(sb);  
        return;  
    }  
}

```

