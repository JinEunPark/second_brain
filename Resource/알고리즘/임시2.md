



- [11053번. 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)
- [11054번. 가장 긴 바이토닉 부분 수열](https://www.acmicpc.net/problem/11054)
- [11722번. 가장 긴 감소하는 부분 수열](https://www.acmicpc.net/problem/11722)
- [12015번. 가장 긴 증가하는 부분 수열 2](https://www.acmicpc.net/problem/12015)
- [12738번. 가장 긴 증가하는 부분 수열 3](https://www.acmicpc.net/problem/12738)
- [14002번. 가장 긴 증가하는 부분 수열 4](https://www.acmicpc.net/problem/14002)
- [14003번. 가장 긴 증가하는 부분 수열 5](https://www.acmicpc.net/problem/14003)


https://www.acmicpc.net/problem/15486
퇴사 2

```Java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
  
        int[] t = new int[n];  
        int[] v = new int[n];  
  
        long[] dp = new long[n + 1];  
  
        for (int i = 0; i < n; i++) {  
            st = new StringTokenizer(br.readLine());  
            t[i] = Integer.parseInt(st.nextToken());  
            v[i] = Integer.parseInt(st.nextToken());  
        }  
  
        for (int i = 0; i < n; i++) {  
            if(i + t[i] <= n)  
            dp[i + t[i]] = Math.max(dp[i] + v[i], dp[i + t[i]]);  
            dp[i + 1] = Math.max(dp[i], dp[i + 1]);  
        }  
  
        System.out.println(dp[n]);  
        return;    }  
}
```

알고리즘은 퇴사 1과 같다 하지만 다시 푸는데도 정말 많은 시간이 걸렸다 다른 점은 정수의 범위를 초과하기 때문에 메모이제이션을 long type 으로 선언했다는 것이다.

https://yabmoons.tistory.com/337 이분이 설명을 참 잘해놨다


https://www.acmicpc.net/problem/2748
fibonacci 오랜만에 쉬어갔다.

```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        long[] dp = new long[n + 5];  
        dp[0] = 0;  
        dp[1] = 1;  
        dp[2] = 1;  
        dp[3] = 2;  
        dp[4] = 3;  
  
        for (int i = 4; i <= n; i++) {  
            dp[i] = dp[i-1]  + dp[i-2];  
        }  
        System.out.println(dp[n]);  
        return;    }  
}

```

https://www.acmicpc.net/problem/2240
https://goodbyeanma.tistory.com/118
자두나무 
이문제는 사실 너무 오랜시간 고만해서 위에 나오는 링크를 참고했다 저분 리얼 지니어스나 ㅎ 화나 이만큼 하면 잘될때가 됐는데 응 아니야 될때까지해

```java
import java.io.*;
import java.util.*;

public class Main {
    
    static int T, W;
    static int[][][] dp;
    static int[] input;
    static int maxCount;
    
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        StringTokenizer stk = new StringTokenizer(br.readLine());
        
        T = Integer.parseInt(stk.nextToken()); // 시간
        W = Integer.parseInt(stk.nextToken()); // 자두를 모을 수 있는 최대 거리
        
        input = new int[T+1]; // 자두가 떨어지는 나무의 위치 배열
        dp = new int[3][T+1][W+2]; // 동적 계획법을 위한 배열
        
        // 각 시간마다 자두가 떨어지는 나무의 위치를 입력받음
        for (int i = 1; i <= T; i++) {
            input[i] = Integer.parseInt(br.readLine());
        }
        
        
        for (int i = 1; i <= T; i++) {
            for (int j = 1; j <= W+1; j++) {
                
                // 자두가 떨어지는 나무의 위치가 1이면
                if (input[i] == 1) {
                    // dp[1][i][j] 갱신
                    dp[1][i][j] = Math.max(dp[1][i-1][j] + 1, dp[2][i-1][j-1] + 1);
                    // dp[2][i][j] 갱신
                    dp[2][i][j] = Math.max(dp[1][i-1][j-1], dp[2][i-1][j]);
                } else { // 자두가 떨어지는 나무의 위치가 2이면
                    // 이전 위치와 현재 위치가 같은 경우를 제외
                    if (i == 1 && j == 1) continue;
                    
                    // dp[1][i][j] 갱신
                    dp[1][i][j] = Math.max(dp[1][i-1][j], dp[2][i-1][j-1]);
                    // dp[2][i][j] 갱신
                    dp[2][i][j] = Math.max(dp[1][i-1][j-1] + 1, dp[2][i-1][j] + 1);
                }
            }
        }
        
        // 마지막 시간에 각 위치에서 모을 수 있는 자두의 최대 개수를 계산
        for (int i = 1; i <= W+1; i++) maxCount = Math.max(dp[1][T][i], dp[2][T][i]);
        
        // 결과 출력
        bw.write(maxCount + "");
        bw.close();
        br.close();
        
    }
}

```

이렇게 보면 점화식이 어렵지만 말로 풀면 조금 더 쉬워진다.
우선 나무당 테이블 하나라고 가정한다. 세로축은 시간 가로축은 움직인 횟수(다른 나무로 슝 한경우)

1. 만일 1먼 나무에서 자두가 하나 떨어진다고 가정하자
2. 그러면 1번 나무의 테이블을 업데이트하기 위해서 고려해야할 것은 2가지 이다. (편의를 위해서 지금 현재 1번 나무에서 자두가 뚝! 떨어지는 경우라면)
	1. 움직이지 않고 제자리에서 받아먹는 경우 ->  ``` dp[첫번째 나무][바로 직전시간][동일한 움직임 횟수]``` -> ``` dp[1][i-1][j] + 1```

	2. 2번 나무에서 움직여서 자두를 받아먹는 경우 -> ```dp[두번째나무][바로직전시간][한번 움직이기 전의값]``` -> 여기서 중요한점은 하나 움직이기 전의 값이다. 2 번에 있던경우 1번으로 이동해서 먹어야하니2번에서 1번으러 이동하는데 이때 2번의 값은 현재 j 에서 하나 전이라는 점이다! -> ```dp[2][i-1][j-1] + 1 ```
	3. 결론적으로 
		```java
		dp[1][i][j] = Math.max(dp[1][i-1][j] + 1, dp[2][i-1][j-1] + 1);
		```

그렇다면 i 의 시점에 j 번 이동하고 1 번에 자두가 떨어지는 순간의 2번 나무는 어떻게 해야하는가
```java
	dp[2][i][j] = Math.max(dp[1][i-1][j-1], dp[2][i-1][j]);
```

위에서 볼 수 있듯이 (직전 시간, 움직인 횟수 하나전의 1번 나무) 그리고 (직전 시점, 동일한 이동횟수의 2번 나무) 중 더 큰것으로 업데이트한다.
복습 코드
 
```java
package run;  
  
import java.io.*;  
import java.util.*;  
  
class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        int n = Integer.parseInt(st.nextToken());  
        int move = Integer.parseInt(st.nextToken());  
        int[] arr = new int[n + 1];  
        int[][][] dp = new int[3][move + 2][n+1];//움 시간  
  
        for (int i = 1; i <= n; i++) {  
            arr[i] = Integer.parseInt(br.readLine());  
        }  
  
        for (int i = 1; i <= n; i++) {  
            if(arr[i] == 1){  
                for (int j = 1; j <= move+1; j++) {  
                    dp[1][j][i] = Math.max(dp[1][j][i-1] + 1, dp[2][j-1][i-1] + 1);  
                    dp[2][j][i] = Math.max(dp[2][j][i-1] , dp[1][j-1][i-1]);  
                }  
            }else{  
                for (int j = 1; j <= move+1; j++) {  
                    if(i == 1 && j == 1) continue;  
                    // 자두는 1번 자두나무 아래에 위치해 있다고 한다. 이 문제 조건 때문에 1 번만 초기화하기 위해서 2인 경우엔 생략하는 조건문을 추가했다.  
  
                    dp[2][j][i]  = Math.max(dp[2][j][i-1] + 1, dp[1][j-1][i-1] + 1);  
                    dp[1][j][i]  = Math.max(dp[1][j][i-1] , dp[2][j-1][i-1]);  
                }  
            }  
        }  
  
        int answer = 0;  
  
        for (int i = 1; i < 3; i++) {  
            answer = Math.max(dp[i][move + 1][n], answer);  
        }  
  
        System.out.println(answer);  
  
        return;    }  
}
```