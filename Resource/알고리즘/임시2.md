
https://www.acmicpc.net/problem/2573
```java
package run;  
  
import java.io.*;  
import java.util.*;  
import java.util.function.Consumer;  
  
class Main {  
    static int melted = 0;  
    public static int getCount(int[][] map){  
        int count = 0;  
        boolean[][] v = new boolean[map.length][map[0].length];  
        for (int i = 0; i < map.length; i++) {  
            for (int j = 0; j < map[0].length; j++) {  
                if(!v[i][j] && map[i][j] != 0){  
                    bfs(map,i,j,v);  
                    count++;  
                }  
            }  
        }  
        return count;  
    }  
  
    public static void bfs(int[][] map, int x, int y, boolean[][] v){  
        v[x][y] = true;  
        Queue<int[]> q = new LinkedList<>();  
        q.add(new int[]{x,y});  
  
        int[] dx = {0,0,1,-1};  
        int[] dy = {1,-1,0,0};  
  
        while(!q.isEmpty()){  
  
            int[] c = q.poll();  
  
            for (int i = 0; i < 4; i++) {  
                int nx = dx[i] + c[0];  
                int ny = dy[i] + c[1];  
  
                if(nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length  
                        || v[nx][ny] || map[nx][ny] == 0)  
                    continue;  
                v[nx][ny] = true;  
                q.add(new int[]{nx,ny});  
            }  
        }  
    }  
  
    public static void year(int[][] map) {  
        int[] dx = {0, 0, -1, 1};  
        int[] dy = {1, -1, 0, 0};  
        Queue<int[]> q = new LinkedList<>();  
  
        for (int i = 0; i < map.length; i++) {  
            for (int j = 0; j < map[0].length; j++) {  
                if (map[i][j] == 0) {  
                    for (int k = 0; k < 4; k++) {  
                        int nx = i + dx[k];  
                        int ny = j + dy[k];  
  
                        if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length  
                                || map[nx][ny] == 0)  
                            continue;  
                        q.add(new int[]{nx, ny});  
                    }  
                }  
            }  
        }  
  
        q.stream().forEach((c)->{  
            if(map[c[0]][c[1]] != 0){  
                map[c[0]][c[1]] = map[c[0]][c[1]] -1;  
                if(map[c[0]][c[1]] == 0){  
                    ++ melted;  
                }  
            }  
        });  
    }  
    public static void main(String[] args) throws IOException {  
  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int n = Integer.parseInt(st.nextToken());  
        int m = Integer.parseInt(st.nextToken());  
  
        int[][] map = new int[n][m];  
        int max_g = 0;  
  
        for (int i = 0; i < n; i++) {  
            String[] s = br.readLine().split(" ");  
  
            for (int j = 0; j < m; j++) {  
                int tmp = Integer.parseInt(s[j]);  
                if(tmp == 0) ++ melted;  
                if(max_g < tmp) max_g = tmp;  
                map[i][j] = tmp;  
            }  
        }  
  
        if(max_g == 0){  
            System.out.println("0");  
            return;        }  
  
        int ans = 0;  
        int time = 0;  
  
        if(2 <= getCount(map)){  
            System.out.println(ans);  
            return;        }  
  
        while(true) {  
            if(melted == n*m)  
                break;  
  
  
            time++;  
            year(map);  
  
            if(2 <= getCount(map)){  
                ans = time;  
                break;            }  
        }  
  
        System.out.println(ans);  
        return;    }  
}

```

내가 틀린 부분은 time 변수를 어디까지 늘려야 하냐 였다. 처음에는 최대 년수 많큼만 수행하면 모든 빙하가 녹을 것으로 생각했지해 최대의 빙하 크기를 구하는 로직했었다. 하지만 문제의 조건에서  바다 근처만 빙하가 녹으니 가장 중앙에 있는 빙하는 10 년이 지나도 녹지 않을 수 있었댜.

이를 다시 올바르게 계산하기 위해선 녹은 빙하의 수를 세어야한다. 따라서 

```java
q.stream().forEach((c)->{  
    if(map[c[0]][c[1]] != 0){  
        map[c[0]][c[1]] = map[c[0]][c[1]] -1;  
        if(map[c[0]][c[1]] == 0){  
            ++ melted;  
        }  
    }  
});

```

위와 같이 0 을 새어주는 로직을 추가했다.

그리고 처음에 틀렸던 이유는 빙하가 녹는 동시성이다. 코드를 짤때 1년차에 1 이었다가 0 이된 수가  다시  반복문을 통해서 0년차에 0 으로 인식되어서 추가로 주위의 빙하를 녹여버리는 오류가 생겼다 이를 한번에 처리하기 위해서 year 코드를 0 인지점의 사방을 큐에 삼입하고 삽입되어진 좌표의 숫자를 한번에 반영하도록 했다.
코드는 다음과 같다.

```java
public static void year(int[][] map) {  
    int[] dx = {0, 0, -1, 1};  
    int[] dy = {1, -1, 0, 0};  
    Queue<int[]> q = new LinkedList<>();  
  
    for (int i = 0; i < map.length; i++) {  
        for (int j = 0; j < map[0].length; j++) {  
            if (map[i][j] == 0) {  
                for (int k = 0; k < 4; k++) {  
                    int nx = i + dx[k];  
                    int ny = j + dy[k];  
  
                    if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[0].length  
                            || map[nx][ny] == 0)  
                        continue;  
                    q.add(new int[]{nx, ny});  //바로 반영하지 않고 큐에 삽입
                }  
            }  
        }  
    }  
  
    q.stream().forEach((c)->{  //추후 동시에 반영
        if(map[c[0]][c[1]] != 0){  
            map[c[0]][c[1]] = map[c[0]][c[1]] -1;  
            if(map[c[0]][c[1]] == 0){  
                ++ melted;  
            }  
        }  
    });  
}

```

