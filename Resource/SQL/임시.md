https://school.programmers.co.kr/learn/courses/30/lessons/144855

```sql
-- 코드를 입력하세요
SELECT CATEGORY , SUM(BSS.SALES_SUM) AS TOTAL_SALES
FROM BOOK B,(SELECT BOOK_ID, SUM(SALES) AS SALES_SUM
            FROM BOOK_SALES
            WHERE MONTH(SALES_DATE) = 1 AND YEAR(SALES_DATE) = "2022"
            GROUP BY BOOK_ID) BSS
WHERE B.BOOK_ID = BSS.BOOK_ID
GROUP BY B.CATEGORY
ORDER BY B.CATEGORY ASC;
```

https://1day1code.tistory.com/entry/SQL-WHERE%EC%A0%88-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90-BETWEEN-%EC%97%B0%EC%82%B0%EC%9E%90
이건 비교 연산자
https://redcow77.tistory.com/260
이건 if 문 



https://school.programmers.co.kr/learn/courses/30/lessons/157340

```sql
select c1.car_id, if(isnull(c2.car_id) , "대여 가능", "대여중") as avaliability
from (select distinct car_id 
      from car_rental_company_rental_history ) c1
left outer join (select distinct car_id 
       from car_rental_company_rental_history c
       where "2022-10-16" between c.start_date and c.end_date) c2
       on c1.car_id = c2.car_id
order by c1.car_id desc;
```

https://school.programmers.co.kr/learn/courses/30/lessons/151139

```sql
select month(c.start_date) as MONTH , CAR_ID, count(car_id) as RECORDS
from CAR_RENTAL_COMPANY_RENTAL_HISTORY c
where c.car_id in (select car_id
                  from CAR_RENTAL_COMPANY_RENTAL_HISTORY cr
                  where cr.start_date between "2022-08-01" and "2022-10-31"
                  group by cr.car_id
                  having count(car_id) > 4)
group by c.car_id , month(c.start_date)
having records > 0
order by month(c.start_date) asc, c.car_id desc;
```

틀렸다...

```sql
select month(c.start_date) as MONTH , CAR_ID, count(car_id) as RECORDS
from CAR_RENTAL_COMPANY_RENTAL_HISTORY c
where c.car_id in (select car_id
                  from CAR_RENTAL_COMPANY_RENTAL_HISTORY cr
                  where cr.start_date between "2022-08-01" and "2022-10-31"
                  group by cr.car_id
                  having count(car_id) > 4)
     and c.start_date between "2022-08-01" and "2022-10-31"
group by month(c.start_date), c.car_id 
having records > 0
order by month(c.start_date) asc, c.car_id desc;
```

정답 코드이고 틀린 이유는 서브쿼리에선 날짜를 적용하고 메인 쿼리에서는 날짜를 적용하지 않아서 모든날짜에서 조회되었기 때문...
그리고 헷갈린 부분이 있는데 between 은 x 이상 y 이하의 조건이다. 해당 수를 포함한다!


https://school.programmers.co.kr/learn/courses/30/lessons/133026

```sql
select ingredient_type, sum(f.total_order) as total_order
from first_half f
join icecream_info i on f.flavor = i.flavor
group by i.ingredient_type
order by total_order asc;
```

https://school.programmers.co.kr/learn/courses/30/lessons/131116
정답코드

```sql
select f1.category, f1.price as max_price, product_name
from food_product f1, (select category, max(price) as price
                   from food_product
                   group by category) f2
where f1.category = f2.category 
    and f1.price = f2.price 
    and (f1.category like "과자" 
    or f1.category like "김치" 
    or f1.category like "국" 
    or f1.category like "식용유")
order by f1.price desc;
```

틀린코드
틀린코드는 사실 정말 사소한 차이다 쿼리 결과에 같은 카테고리에 많은 음식들이 한번에 쿼리 되어서 놀랐다 그 이유는 사실 쿼리에서 소괄호 하나가 빠졌다 해당 카테고리들을 허용하기 위해서 or 조건을 사용했는데 이때 괄호를 사용하지 않아서 해당 카테고리면 가격과 카테고리에 상관없이 출력됬다.

```sql
select f1.category, f1.price as max_price, product_name
from food_product f1, (select category, max(price) as price
                   from food_product
                   group by category) f2
where f1.category = f2.category 
    and f1.price = f2.price 
    and f1.category like "과자" 
    or f1.category like "김치" 
    or f1.category like "국" 
    or f1.category like "식용유"
order by f1.price desc;
```



https://school.programmers.co.kr/learn/courses/30/lessons/131532

```sql
틀린코드
select year(o.sales_date) as year, month(o.sales_date) as month , gender, count( o.user_id) as users
from online_sale o
join user_info u on o.user_id = u.user_id
group by year(o.sales_date), month(o.sales_date), u.gender
having isnull(u.gender) = false
order by year(o.sales_date) asc, month(o.sales_date) asc, u.gender asc;

맞은코드
select year(o.sales_date) as year, month(o.sales_date) as month , gender, count(distinct o.user_id) as users
from online_sale o
join user_info u on o.user_id = u.user_id
group by year(o.sales_date), month(o.sales_date), u.gender
having isnull(u.gender) = false
order by year(o.sales_date) asc, month(o.sales_date) asc, u.gender asc;
```

틀린코드와 맞은 코드의 한가지 차이점은 저 distinct 유무인데 그 이유는 월별로 그룹화를 했기 때문에 같은 달에 유저가 2번 구매하면 2명으로 처리되서이다 문제에서 조건이 월별 구매 유저 수를 구하는 것이기 때문에 같은 유저는 한번만 세야한다.

https://school.programmers.co.kr/learn/courses/30/lessons/59412

```sql
select extract(hour from o.datetime) as hour, count(animal_id) as count
from animal_outs o
where extract(hour from o.datetime) between 9 and 19
group by extract(hour from o.datetime)
order by hour asc;
```

extract 함수를 몰라서 어려웠다
https://schatz37.tistory.com/53
### 2.3. extract() : 날짜 및 시간에서 필요한 정보만 뽑아오기

extract() 함수는 아래와 같은 Format으로 사용이 되는데요.

> **EXTRACT(part FROM date_expression)**

여기서 알아두고 가면 좋을 부분은 **part** 부분입니다.  
쉽게 말해서 '날짜/시간에서 어떤 부분을 가져올 건데?'라는 부분을 알려주는 자리라고 생각하면 되는데, 그 종류를 한번 살펴보고 시작해 봅시다.

|   |   |   |   |
|---|---|---|---|
|Part|사용법|설명|반환 데이터 타입|
|YEAR|extract(year from 날짜/시간)|날짜/시간 중 연도 추출|INT64|
|QUARTER|extract(quarter from 날짜/시간)|날짜/시간 중 분기 추출|INT64|
|MONTH|extract(month from 날짜/시간)|날짜/시간 중 월 추출|INT64|
|DAY|extract(day from 날짜/시간)|날짜/시간 중 일자 추출|INT64|
|WEEK|extract(week from 날짜/시간)|날짜/시간 중 주 추출  <br>(1년 중 몇번째 주인지?)|INT64|
|DAYOFWEEK|extract(dayofweek from 날짜/시간)|날짜/시간 중 요일 추출   <br>(  1 = 일요일, 2 = 월요일 ... ,7 = 토요일)|INT64|
|HOUR|extract(hour from 날짜/시간)|날짜/시간 중 시간 추출|INT64|
|MINUTE|extract(minute from 날짜/시간)|날짜/시간 중 분 추출|INT64|
|SECOND|extract(second from 날짜/시간)|날짜/시간 중 초 추출|INT64|
|DATE|extract(date from 날짜/시간)|날짜/시간 중 날짜 추출|DATE|
|DATETIME|extract(datetime from 날짜/시간)|날짜/시간 중 날짜 및 시간 추출   <br>(날짜/시간에 TIMESTAMP 형태가 들어가야 함)|DATETIME|

위와 같이 Part 가 존재하는데요.  
DATE, DATETIME과 같이 완성된 날짜/시간 타입을 Part에 넣는 게 아니라면 모두 INT64 형태의 데이터타입으로 값이 반환된다는 점 알아두시면 좋을 것 같습니다.  
   
extract() 함수를 사용한 예시는 아래와 같습니다.

```
select   extract(year from current_datetime('+09:00')) as ext_yyyy  , extract(quarter from current_datetime('+09:00')) as ext_qq  , extract(month from current_datetime('+09:00')) as ext_mm  , extract(day from current_datetime('+09:00')) as ext_dd  , extract(week from current_datetime('+09:00')) as ext_week -- 1년의 몇 번째 주  , extract(dayofweek from current_datetime('+09:00')) as ext_dow -- 1 = 일요일, 2 = 월요일 ... ,7 = 토요일  , extract(hour from current_datetime('+09:00')) as ext_hh  , extract(minute from current_datetime('+09:00')) as ext_minute  , extract(second from current_datetime('+09:00')) as ext_second  , extract(date from current_datetime('+09:00')) as ext_date  , extract(datetime from current_timestamp()) as ext_dt
```

![](https://blog.kakaocdn.net/dn/cx3s4Z/btr5paQCKbv/gt2gPkq8QOQ0YZkMlDsPjk/img.png)




https://school.programmers.co.kr/learn/courses/30/lessons/59413

SQL문을 실행하면 다음과 같이 나와야 합니다.

| HOUR | COUNT |
| ---- | ---- |
| 0 | 0 |
| 1 | 0 |
| 2 | 0 |
| 3 | 0 |
| 4 | 0 |
| 5 | 0 |
| 6 | 0 |
| 7 | 3 |
| 8 | 1 |
| 9 | 1 |
| 10 | 2 |
| 11 | 13 |
| 12 | 10 |
| 13 | 14 |
| 14 | 9 |
| 15 | 7 |
| 16 | 10 |
| 17 | 12 |
| 18 | 16 |
| 19 | 2 |
| 20 | 0 |
| 21 | 0 |
| 22 | 0 |
| 23 | 0 |
위의 표를 만드는 것이 어려웠다... 왜냐하면 해당 테이블에 존재하지 않는 시간대가 있기 때문인데 이를 해결하기 위해서는 sql 에서 변수를 만드는 문법을 알아야해서 간단하게 정리해본다
일단 시작하기에 앞서서  mysql 에는 두가지 변수가 존재하는데 하나는 사용자 정의 변수이고 다른 하나는 지역변수이다 
1. 사용자 정의 변수
	1.  변수는 세션(Session)단위로 실행이 되기 때문에, 한 클라이언트에서 정의한 사용자 변수는 다른 클라이언트에서 보거나 사용할 수 없다.
	2. 사용자 정의 변수 선언 및 초기화
		~~~sql
		set @time := -1 or set @time = -1
		~~~
		위의 예시처럼 변수를 선언하는 것이 가능한데 두가지를 사용할 수 있다 기본적으로 
		1. set 키워드와 함께 선언하고 초기화하는 경우 '='  ':=' 두가지를 모두 사용할 수 있다
		2. set 키워드 이외의 공간에서 선언하고 사용하는 경우 ':=' 반드시 이 키워드를 사용해야한다.
	~~~sql
	set @time = -1;
select 
    (@time := @time +1) as hour, 
    (select count(animal_id) 
    from animal_outs o
    where @time = extract(hour from o.datetime))
    as count
from 
    animal_outs
where @time < 23
	~~~ 

사용예시

2. 지역변수
	1. 지역변수 선언 및 초기화
		~~~sql
	delimiter $$
	    create procedure testpro(in v1 int)
	    begin
	        declare start int default 1;
	    end $$
	delimiter;
	call testpro(1)
		~~~
	
	위의 코드에서 declare 변수이름 자료형 문볍을 지키며 선언했다. 함고로 위의 default 키워드를 사용하지 않으면 초기값은 null 이다. 그러면 지역변수를 다시 할당할 때는? SET @Age = 10;
	