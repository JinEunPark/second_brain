
https://school.programmers.co.kr/learn/courses/30/lessons/131114


​

```sql
select warehouse_id, warehouse_name, address, if(isnull(freezer_yn) = true, "N", freezer_yn) as freezer_yn
from food_warehouse w
where w.address like "%경기%"
order by w.warehouse_id;
```


https://school.programmers.co.kr/learn/courses/30/lessons/59039select 

```sql
animal_id
from animal_ins s
where isnull(s.name ) = true
order by animal_id asc;
```



https://school.programmers.co.kr/learn/courses/30/lessons/59407

```sql
select animal_id
from animal_ins a
where isnull(a.name)=false
order by animal_id asc;
```


https://school.programmers.co.kr/learn/courses/30/lessons/59410

```sql
select animal_type, if(isnull(name)= true,"No name",name), sex_upon_intake
from animal_ins;
```


https://school.programmers.co.kr/learn/courses/30/lessons/131528

```sql
select count(user_id) as users
from user_info
where isnull(age) = true;

```



https://school.programmers.co.kr/learn/courses/30/lessons/133027


limit 키워드를 이용한 방법

```sql
select f.flavor
from (select flavor, sum(total_order) as ts
     from first_half
     group by flavor) f,
     (select flavor, sum(total_order) as ts
     from july
     group by flavor) j
where f.flavor = j.flavor
order by (f.ts + j.ts) desc
limit 3;

```

`SELECT` 명령에서 **결과값으로 반환되는 행을 제한**할 수 있었다.

이번에는 `LIMIT` 구로 **행의 갯수를 제한**하는 방법에 대해 알아보자. 이 방법은 많은 데이터를 페이지로 나눠서 보여주는 방법에서 사용된다.

1SELECT 열 명 FROM 테이블 명 LIMIT 행수 [OFFSET 시작행]

들어가기에 앞서, `LIMIT` 구는 **표준 SQL이 아니다.**

**MySQL**과 **PostgreSQL**에서 사용할 수 있는 문법이라는 점에 유의하자.

## 2. 오프셋 지정

시작할 때 말했듯이 대량의 데이터를 한 번에 불러와서 화면에 표시하는 것은 **기능적이나 속도 측면에서도 효율적이지 못하다.**

일반적으로 **페이지 나누기(_Pagination_)** 기능을 사용하는데 이때 `LIMIT`와 `OFFSET`을 사용하여 처리할 수 있다.

예를 들어 한 페이지당 5개의 데이터를 표시하도록 하려면 첫 페이지는 `LIMIT 5`로 결괏값을 표시하면 된다.

그리고 그 다음 페이지는 **6번째 행부터 5건의 데이터를 표시**하면 된다.

이때 몇 번째 행부터 데이터를 취득할 것인지를 가리키는 방법이 `OFFSET`이다.

1SELECT * FROM sample33 LIMIT 3 OFFSET 0;





https://school.programmers.co.kr/learn/courses/30/lessons/157339

그냥 너무 어려웠어서 처음 부터 다시 풀어보면 좋을 것 같다.

```sql
select c.car_id, c.car_type, round(c.daily_fee * 30 * ((100 - plan.discount_rate)/100) ,0) as fee
from CAR_RENTAL_COMPANY_CAR c
join  CAR_RENTAL_COMPANY_DISCOUNT_PLAN as plan on plan.car_type = c.car_type
where c.car_id not in (select car_id
                        from CAR_RENTAL_COMPANY_RENTAL_HISTORY h
                        where ("2022-11-01" < h.end_date and "2022-12-01" > h.start_date ) 
                        group by car_id) and plan.DURATION_TYPE = '30일 이상'
HAVING C.CAR_TYPE IN ('세단', 'SUV') AND (FEE>=500000 AND FEE<2000000) 
order by fee desc, c.car_type asc, c.car_id desc;

```


https://school.programmers.co.kr/learn/courses/30/lessons/131117

```sql
select p.product_id, p.product_name, (sum(o.amount) * p.price) as total_sales
from food_order o
join food_product p on o.product_id = p.product_id
where month(o.produce_date) = 5
group by o.product_id
order by total_sales desc, p.product_id asc;
```


https://school.programmers.co.kr/learn/courses/30/lessons/144854

```sql
select book_id, author_name, date_format(published_date,"%Y-%m-%d") as published_date
from book b
join author a on b.author_id = a.author_id
where b.category = "경제" 
order by b.published_date asc;
```



https://school.programmers.co.kr/learn/courses/30/lessons/131124

```sql
select m.member_name, r.review_text, date_format(r.review_date,"%Y-%m-%d") as review_date
from rest_review r
join member_profile m on r.member_id = m.member_id
where r.member_id in (
    select member_id #2
    from rest_review r
    group by member_id
    having count(member_id)   = (select max(sub.count) as max_count
                                from (select count(member_id) as count
                                      from rest_review r
                                      group by member_id) as sub) # 1

)
order by r.review_date asc, r.review_text asc;
```

1 번 서브 쿼리를 이용해서 가장 큰 아이디가 리뷰를 작성한 횟수 INT 값을 가져왔다. 사실 이것 조차도 두개의 서브쿼리로 이루어져있다. 첫번째로 레스트 리뷰 테이블을 아이디 별로 묶어서 사용된 횟수를 구하고 이를 다시 쿼리해 max 집계함수를 적용했다. 

2 번 에서는 사용된 횟수가 max 와 같은 경우의 member_id 를 모두 가져왔다.
이 문제를 풀기 위해서 총 3번의 서브쿼리를 사용했는데 성능상으로 좋지 못한것 같다. 따라서 다른 방법이 필요할 것같아서 찾아봤다.

https://velog.io/@zinu/SQLD-2%EA%B3%BC%EB%AA%A9-SQL-%EA%B8%B0%EB%B3%B8-%EB%B0%8F-%ED%99%9C%EC%9A%A9-%EC%9C%88%EB%8F%84%EC%9A%B0-%ED%95%A8%EC%88%98


```sql
SELECT m.member_name, r.review_text, DATE_FORMAT(r.review_date, "%Y-%m-%d") AS review_date
FROM rest_review r
JOIN member_profile m ON r.member_id = m.member_id
JOIN (
    SELECT member_id, COUNT(member_id) AS review_count, MAX(COUNT(member_id)) OVER () AS max_review_count
    FROM rest_review
    GROUP BY member_id
) AS counts ON r.member_id = counts.member_id
WHERE counts.review_count = counts.max_review_count
ORDER BY r.review_date ASC, r.review_text ASC;
```

위의 코드는 테이블 스켄 관점에서 한번의 테이블 스켄이 일어나는 코드이다 윈도우 함수를 사용했기 때문이다.

~~~sql
SELECT member_id, COUNT(member_id) AS review_count, MAX(COUNT(member_id)) OVER () AS max_review_count
    FROM rest_review
    GROUP BY member_id
~~~

|member_id|review_count|max_review_count|
|---|---|---|
|min09125@naver.com|2|3|
|ksjs1115@gmail.com|3|3|
|jihoon93@hanmail.net|1|3|
|doooj219@gmail.com|2|3|
|yoonsy94@gmail.com|2|3|
|soso94@naver.com|3|3|
|sw900429@nate.com|2|3|
|yelin92@gmail.com|2|3|
|woojune96@naver.com|2|3|
|jimin88@naver.com|1|3|
|seoyeons@naver.com|2|3|
|yeahjin98@nate.com|1|3|
|yeseo92@naver.com|2|3|
|jihoo95@nate.com|2|3|
|minjea985@naver.com|3|3|
위를 실행하면 이렇게 테이블이 만들어진다. over 는 원도우 함수를 이용하기 위해서 사용하는 것으로 기본적으로 over( partition by 컬럼  order by 컬럼) 형태이다. 간단하게 설명하면 어떻게 나눌 것인지 나눈것을 어떤 순서로 적용할 것인지 

~~~sql
함수(컬럼) OVER (Partition by 컬럼 Order by 컬럼)  
  
함수 : Min, Max, Sum, Count, Rank 등과 같은 기존의 함수 or 윈도우 함수용으로 추가된 함수 (Row_number 등)  
OVER : over 은 윈도우 함수에서 꼭 들어가야 하며 Over 내부에 Partition By 절과 Order by 절이 들어갑니다.  
partition by : 전체 집합을 어떤 기준(컬럼)에 따라 나눌지를 결정하는 부분.  
order by : 어떤 항목(컬럼)을 기준으로 순위를 정할 지 결정하는 부분
~~~

위의 예시에서는 over 에는 빈 값이 들어가는데 빈값을 파라미터로 사용할 경우에는 전체 쿼리 집합이 대상이 된다. 따라서 위의 쿼리에서는

```sql
MAX(COUNT(member_id)) OVER () AS max_review_count 
```

인데 전체 그룹별 최댓값을 구해서 컬럼으로 추가하는 코드가 된다.



https://school.programmers.co.kr/learn/courses/30/lessons/59042

```sql
select o.animal_id, o.name
from animal_outs o
left outer join animal_ins i on i.animal_id = o.animal_id
where isnull(i.intake_condition) = true
order by o.animal_id asc, o.name asc;
```

left outer join 을 이용했다 그래야 join 할 데이터가 존재하지 않더라도 null 값으로 조인하기 때문이다 그냥 Inner join 을 수행하면 아무것도 나타나지 않는다.


https://school.programmers.co.kr/learn/courses/30/lessons/59043


```sql
select o.animal_id, o.name
from animal_outs o
join animal_ins i on i.animal_id = o.animal_id
where o.datetime < i.datetime
order by i.datetime asc;
```
위의 문제는 간단하게 테이블에서 in 한 시각이 out 한 시각보다 빠른 경우를 찾는 것이다.


https://school.programmers.co.kr/learn/courses/30/lessons/59044

```sql
select i.name, i.datetime
from animal_ins i
left outer join animal_outs o on o.animal_id = i.animal_id
where isnull(o.datetime) = true 
order by i.datetime asc
limit 3;
```